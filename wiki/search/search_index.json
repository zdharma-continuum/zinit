{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home # This is the Zplugin wiki. The goal is to complement the README by providing a more easy to approach, more intuitively organized (with help of the MkDocs project-documentation tool) and also a more in-depth information.","title":"Home"},{"location":"#home","text":"This is the Zplugin wiki. The goal is to complement the README by providing a more easy to approach, more intuitively organized (with help of the MkDocs project-documentation tool) and also a more in-depth information.","title":"Home"},{"location":"Code-Documentation/","text":"Code documentation # Here is code documentation generated using Zshelldoc . There are 4 Zplugin's source files, the main one is zplugin.zsh. The documentation lists all functions, interactions between them, their comments and features used. zplugin.zsh \u2013 always loaded, in .zshrc ( pdf ) zplugin-side.zsh \u2013 common functions, loaded by *-install and *-autoload scripts ( pdf ) zplugin-install.zsh \u2013 functions used only when installing a plugin or snippet ( pdf ) zplugin-autoload.zsh \u2013 functions used only in interactive Zplugin invocations ( pdf )","title":"Overview"},{"location":"Code-Documentation/#code_documentation","text":"Here is code documentation generated using Zshelldoc . There are 4 Zplugin's source files, the main one is zplugin.zsh. The documentation lists all functions, interactions between them, their comments and features used. zplugin.zsh \u2013 always loaded, in .zshrc ( pdf ) zplugin-side.zsh \u2013 common functions, loaded by *-install and *-autoload scripts ( pdf ) zplugin-install.zsh \u2013 functions used only when installing a plugin or snippet ( pdf ) zplugin-autoload.zsh \u2013 functions used only in interactive Zplugin invocations ( pdf )","title":"Code documentation"},{"location":"Compiling-programs/","text":"zplugin ice as\"program\" atclone\"rm -f src/auto/config.cache; ./configure\" \\ atpull\"%atclone\" make pick\"src/vim\" zplugin light vim/vim as\"program\" \u2013 add file selected by pick'' to $PATH , do not source it, atclone\"\u2026\" \u2013 execute code after downloading, atpull\"%atclone\" \u2013 execute the same code atclone'' is given, but after successful update, make \u2013 run make after atclone'' and atpull'' (note: make'!' will execute before them), pick\"src/vim\" \u2013 set executable flag on src/vim , hint that src/ should be added to $PATH . The same but with installation (i.e. make install is being run) under $ZPFX ( ~/.zplugin/polaris by default): zplugin ice as\"program\" atclone\"rm -f src/auto/config.cache; \\ ./configure --prefix=$ZPFX\" atpull\"%atclone\" \\ make\"all install\" pick\"$ZPFX/bin/vim\" zplugin light vim/vim as\"program\" \u2013 as above, atclone\"\u2026\" \u2013 as above plus pass --prefix=$ZPFX to ./configure , to set the installation directory, atpull\"%atclone\" \u2013 as above, make \u2013 as above, but also run the install target, pick\"src/vim\" \u2013 as above, but for different path ( $ZPFX/bin/vim ). zplugin ice as\"program\" make'!' atclone'./direnv hook zsh > zhook.zsh' \\ atpull'%atclone' src\"zhook.zsh\" zplugin light direnv/direnv make'!' \u2013 execute make before atclone'' and before atpull'' (see make above), src\"zhook.zsh\" \u2013 source file zhook.zsh . In general, Direnv works by hooking up to Zsh. The code that does this is provided by program direnv (built by make'' ). Above atclone'' puts this code into file zhook.zsh , src'' sources it. This way direnv hook zsh is executed only on clone and update, and Zsh starts faster.","title":"Compiling Programs"},{"location":"Direnv-explanation/","text":"The project direnv/direnv registers itself in Zshell to modify environment on directory change. This registration is most often done by eval \"$(direnv hook zsh)\" added to zshrc. Drawback of this standard procedure is that direnv binary is ran on every shell startup and significantly slows it down. Zplugin allows to solve this in following way: zplugin ice as\"program\" make'!' atclone'./direnv hook zsh > zhook.zsh' \\ atpull'%atclone' pick\"direnv\" src\"zhook.zsh\" zplugin light direnv/direnv make'!' \u2013 compile direnv (it's written in Go lang); the exclamation mark means: run the make first, before atclone and atpull hooks, atclone'\u2026' \u2013 initially (right after installing the plugin) generate the registration code and save it to zhook.zsh (instead of passing to eval ), atpull'%atclone' \u2013 regenerate the registration code also on update ( atclone'' runs on installation while atpull runs on update of the plugin), src\"zhook.zsh\" \u2013 load ( source ) the generated registration code, pick\"direnv\" \u2013 ensure +x permission on the binary, as\"program\" \u2013 the plugin is a program, there's no main file to source. This way registration code is generated once every installation and update, to then be simply sourced without running direnv . The project is also available as binary Github release. This distribution can be installed by: zplugin ice from\"gh-r\" as\"program\" mv\"direnv* -> direnv\" \\ './direnv hook zsh > zhook.zsh' atpull'%atclone' pick\"direnv\" zplugin light direnv/direnv from\"gh-r\" \u2013 install from Github releases , mv\"\u2026\" \u2013 after installation, rename direnv.linux-386 or similar file to direnv , atclone'\u2026' , atpull'\u2026' \u2013 as in previous example, pick\"direnv\" \u2013 as in previous example, as\"program\" \u2013 as in previous example.","title":"Direnv Explanation"},{"location":"Example-Minimal-Setup/","text":"Example Minimal Setup # zplugin ice wait\"0\" blockf zplugin light zsh-users/zsh-completions zplugin ice wait\"0\" atload\"_zsh_autosuggest_start\" zplugin light zsh-users/zsh-autosuggestions zplugin ice wait\"0\" atinit\"zpcompinit; zpcdreplay\" zplugin light zdharma/fast-syntax-highlighting light \u2013 load the plugin in light mode, in which the tracking of plugin (i.e. activity report gathering, accessible via the zplugin report {plugin-spec} subcommand) is being disabled; note that for Turbo mode, the performance gains are actually 0 , so in this mode you can load all plugins with the tracking, i.e. by using zplugin ice wait'0'; zplugin load {plugin-spec} commands, wait\"0\" \u2013 load 0 seconds (about 110 ms exactly) after prompt, atinit'' \u2013 execute code before loading plugin, atload'' \u2013 execute code after loading plugin, zpcompinit \u2013 equals to autoload compinit; compinit , zpcdreplay \u2013 execute compdef \u2026 calls that plugins did \u2013 they were recorded, so that compinit can be called later (it provides the compdef function, so it must be ran before issuing compdef s), syntax-highlighting plugins (like fast-syntax-highlighting or zsh-syntax-highlighting ) expect to be loaded last, even after the completion initialization (i.e. compinit function), hence the atinit'' , which will load compinit right before the plugin, the atinit of the plugin runs also zpcdreplay (i.e. \" zplugin-compdef-replay \"), because after compinit is loaded, the compdef function becomes available, and one can re-run the all earlier automatically-caught compdef calls, loosing nothing from the original behavior, add lucid ice-mod to silence the under-prompt messages. The same setup but without using Turbo mode (i.e. no wait'' ice): zplugin ice blockf zplugin light zsh-users/zsh-completions zplugin light zsh-users/zsh-autosuggestions autoload compinit compinit zplugin light zdharma/fast-syntax-highlighting","title":"Example Minimal Setup"},{"location":"Example-Minimal-Setup/#example_minimal_setup","text":"zplugin ice wait\"0\" blockf zplugin light zsh-users/zsh-completions zplugin ice wait\"0\" atload\"_zsh_autosuggest_start\" zplugin light zsh-users/zsh-autosuggestions zplugin ice wait\"0\" atinit\"zpcompinit; zpcdreplay\" zplugin light zdharma/fast-syntax-highlighting light \u2013 load the plugin in light mode, in which the tracking of plugin (i.e. activity report gathering, accessible via the zplugin report {plugin-spec} subcommand) is being disabled; note that for Turbo mode, the performance gains are actually 0 , so in this mode you can load all plugins with the tracking, i.e. by using zplugin ice wait'0'; zplugin load {plugin-spec} commands, wait\"0\" \u2013 load 0 seconds (about 110 ms exactly) after prompt, atinit'' \u2013 execute code before loading plugin, atload'' \u2013 execute code after loading plugin, zpcompinit \u2013 equals to autoload compinit; compinit , zpcdreplay \u2013 execute compdef \u2026 calls that plugins did \u2013 they were recorded, so that compinit can be called later (it provides the compdef function, so it must be ran before issuing compdef s), syntax-highlighting plugins (like fast-syntax-highlighting or zsh-syntax-highlighting ) expect to be loaded last, even after the completion initialization (i.e. compinit function), hence the atinit'' , which will load compinit right before the plugin, the atinit of the plugin runs also zpcdreplay (i.e. \" zplugin-compdef-replay \"), because after compinit is loaded, the compdef function becomes available, and one can re-run the all earlier automatically-caught compdef calls, loosing nothing from the original behavior, add lucid ice-mod to silence the under-prompt messages. The same setup but without using Turbo mode (i.e. no wait'' ice): zplugin ice blockf zplugin light zsh-users/zsh-completions zplugin light zsh-users/zsh-autosuggestions autoload compinit compinit zplugin light zdharma/fast-syntax-highlighting","title":"Example Minimal Setup"},{"location":"Example-Oh-My-Zsh-setup/","text":"# A. setopt promptsubst # B. zplugin ice wait lucid zplugin snippet OMZ::lib/git.zsh # C. zplugin ice wait atload\"unalias grv\" lucid zplugin snippet OMZ::plugins/git/git.plugin.zsh # D. PS1=\"READY >\" # provide a nice prompt till the theme loads zplugin ice wait lucid zplugin snippet OMZ::themes/dstufft.zsh-theme # E. zplugin ice wait lucid zplugin snippet OMZ::plugins/colored-man-pages/colored-man-pages.plugin.zsh # F. zplugin ice wait as\"completion\" lucid zplugin snippet OMZ::plugins/docker/_docker # G. zplugin ice wait atinit\"zpcompinit\" lucid zplugin light zdharma/fast-syntax-highlighting A - Most themes use this option. B - OMZ themes use this library. C - Some OMZ themes use this plugin. It provides many aliases \u2013 atload'' shows how to disable some of them (to use program rgburke/grv ). D - Set OMZ theme. E - Example functional plugin. F - Load Docker completion. G - Normal plugin (syntax-highlighting, at the end, like it is suggested by the plugin's README). Completions provided by git plugin are catched, but ignored. They can be executed using function zpcdreplay appended after zpcompinit; in atinit'' of G . Above setup loads everything after prompt, because of preceding wait ice. That is called Turbo mode , it shortens Zsh startup time by 50%-73% , so e.g. instead of 200 ms, you'll be getting your shell started up after 50 ms (!). The same setup without Turbo mode (prompt will be initially set like in typical, normal setup \u2013 you can remove wait only from the theme plugin to have the same effect while still using Turbo mode for everything remaining): # A. setopt promptsubst # B. zplugin snippet OMZ::lib/git.zsh # C. zplugin ice atload\"unalias grv\" zplugin snippet OMZ::plugins/git/git.plugin.zsh # D. zplugin snippet OMZ::themes/dstufft.zsh-theme # E. zplugin snippet OMZ::plugins/colored-man-pages/colored-man-pages.plugin.zsh # F. zplugin ice as\"completion\" zplugin snippet OMZ::plugins/docker/_docker # G. zplugin ice atinit\"zpcompinit\" zplugin light zdharma/fast-syntax-highlighting In general, Turbo mode can be optionally enabled only for a subset of plugins or for all plugins. It needs Zsh >= 5.3. The Introduction contains more information on Turbo mode.","title":"Example Oh My Zsh Setup"},{"location":"Example-wait-conditions/","text":"Note Turbo mode, i.e. the wait ice that implements it needs Zsh >= 5.3. zplugin ice wait'0' # or just: zplugin ice wait zplugin light wfxr/forgit waits for prompt, instantly (\"0\" seconds) after prompt loads given plugin. zplugin ice wait'[[ -n ${ZLAST_COMMANDS[(r)cras*]} ]]' zplugin light zdharma/zplugin-crasis $ZLAST_COMMANDS is an array build by fast-syntax-highlighting , it contains commands currently entered at prompt, (r) searches for element that matches given pattern ( cras* ) and returns it, -n means: not-empty, so it will be true when users enters \"cras\", after 1 second or less, Zplugin will detect that wait'' condition is true, and load the plugin, which provides command crasis , Screencast that presents the feature: zplugin ice wait'[[ $PWD = */github || $PWD = */github/* ]]' zplugin load unixorn/git-extra-commands waits until user enters a github directory. Turbo mode also support a suffix \u2013 the letter a , b or c . The meaning is illustrated by the following example: zplugin ice wait\"0b\" as\"command\" pick\"wd.sh\" atinit\"echo Firing 1\" lucid zplugin light mfaerevaag/wd zplugin ice wait\"0a\" as\"command\" pick\"wd.sh\" atinit\"echo Firing 2\" lucid zplugin light mfaerevaag/wd # The output Firing 2 Firing 1 As it can be seen, the second plugin has been loaded first. That's because there are now three sub-slots (the a , b and c ) in which the plugin/snippet loadings can be put into. Plugins from the same time-slot with suffix a will be loaded before plugins with suffix b , etc. In other words, instead of wait'1' you can enter wait'1a' , wait'1b' and wait'1c' \u2013 to this way impose order on the loadings regardless of the order of zplugin commands .","title":"Example wait Conditions"},{"location":"GALLERY/","text":"Gallery Of Zplugin Invocations # PRs welcomed :) Programs # zplugin ice from\"gh-r\" as\"program\" zplugin light junegunn/fzf-bin zplugin ice from\"gh-r\" as\"program\" mv\"docker* -> docker-compose\" zplugin light docker/compose zplugin ice as\"program\" atclone\"rm -f src/auto/config.cache; ./configure\" \\ atpull\"%atclone\" make pick\"src/vim\" zplugin light vim/vim zplugin ice as\"program\" make'!' atclone'./direnv hook zsh > zhook.zsh' \\ atpull'%atclone' src\"zhook.zsh\" zplugin light direnv/direnv zplugin ice from\"gh-r\" as\"program\" mv\"direnv* -> direnv\" zplugin light direnv/direnv zplugin ice from\"gh-r\" as\"program\" mv\"shfmt* -> shfmt\" zplugin light mvdan/sh zplugin ice from\"gh-r\" as\"program\" mv\"gotcha_* -> gotcha\" zplugin light b4b4r07/gotcha zplugin ice as\"program\" pick\"yank\" make zplugin light mptre/yank zplugin ice wait\"2\" lucid as'command' pick'src/vramsteg' \\ atclone'cmake .' atpull'%atclone' make # use Turbo mode zplugin light psprint/vramsteg-zsh zplugin ice atclone\"./libexec/pyenv init - > zpyenv.zsh\" \\ atinit'export PYENV_ROOT=\"$PWD\"' atpull\"%atclone\" \\ as'command' pick'bin/pyenv' src\"zpyenv.zsh\" nocompile'!' zplugin light pyenv/pyenv zplugin ice as\"program\" pick\"$ZPFX/sdkman/bin/sdk\" id-as'sdkman' run-atpull \\ atclone\"wget https://get.sdkman.io -O scr.sh; SDKMAN_DIR=$ZPFX/sdkman bash scr.sh\" \\ atpull\"SDKMAN_DIR=$ZPFX/sdkman sdk selfupdate\" \\ atinit\"export SDKMAN_DIR=$ZPFX/sdkman; source $ZPFX/sdkman/bin/sdkman-init.sh\" zplugin light zdharma/null Completions # zplugin ice as\"completion\" zplugin snippet https://github.com/docker/cli/blob/master/contrib/completion/zsh/_docker Scripts # # For GNU ls (the binaries can be gls, gdircolors, e.g. on OS X when installing the # coreutils package from Homebrew or using https://github.com/ogham/exa) zplugin ice atclone\"dircolors -b LS_COLORS > c.zsh\" \\ atpull'%atclone' pick\"c.zsh\" nocompile'!' \\ atload'zstyle \":completion:*\" list-colors \u201c${(s.:.)LS_COLORS}\u201d' # Style the Zsh completion zplugin light trapd00r/LS_COLORS zplugin ice as\"program\" pick\"$ZPFX/bin/git-*\" make\"PREFIX=$ZPFX\" nocompile zplugin light tj/git-extras zplugin ice as\"program\" atclone'perl Makefile.PL PREFIX=$ZPFX' \\ atpull'%atclone' make'install' pick\"$ZPFX/bin/git-cal\" zplugin light k4rthik/git-cal zplugin ice as\"program\" id-as\"git-unique\" pick\"git-unique\" zplugin snippet https://github.com/Osse/git-scripts/blob/master/git-unique zplugin ice as\"program\" cp\"wd.sh -> wd\" mv\"_wd.sh -> _wd\" \\ atpull'!git reset --hard' pick\"wd\" zplugin light mfaerevaag/wd zplugin ice as\"program\" pick\"bin/archey\" zplugin load obihann/archey-osx Plugins # zplugin ice pick\"h.sh\" zplugin light paoloantinori/hhighlighter Snippets # zplugin ice svn pick\"completion.zsh\" src\"git.zsh\" zplugin snippet OMZ::lib zplugin ice svn wait\"0\" lucid atinit\"local ZSH=\\$PWD\" \\ atclone\"mkdir -p plugins; cd plugins; ln -sfn ../. osx\" zplugin snippet OMZ::plugins/osx # Or with most recent Zplugin and with ~/.zplugin/snippets # directory pruned (rm -rf -- ${ZPLGM[SNIPPETS_DIR]}): zplugin ice svn zplugin snippet OMZ::plugins/osx Themes # GEOMETRY_COLOR_DIR=152 zplugin ice wait\"0\" lucid atload\"geometry::prompt\" zplugin light geometry-zsh/geometry zplugin ice pick\"async.zsh\" src\"pure.zsh\" zplugin light sindresorhus/pure zplugin light mafredri/zsh-async # dependency zplugin ice svn silent atload'prompt sorin' zplugin snippet PZT::modules/prompt zplugin ice atload\"fpath+=( \\$PWD );\" zplugin light chauncey-garrett/zsh-prompt-garrett zplugin ice svn atload\"prompt garrett\" silent zplugin snippet PZT::modules/prompt zplugin ice nocompletions compile\"{zinc_functions/*,segments/*,zinc.zsh}\" zplugin load robobenklein/zinc # ZINC git info is already async, but if you want it # even faster with gitstatus in Turbo mode: # https://github.com/romkatv/gitstatus zplugin ice wait'1' atload'zinc_optional_depenency_loaded' zplugin load romkatv/gitstatus # After finishing the configuration wizard change the atload'' ice to: # -> atload'source ~/.p10k.zsh; _p9k_precmd' zplugin ice wait'!' lucid atload'true; _p9k_precmd' nocd zplugin light romkatv/powerlevel10k","title":"Gallery"},{"location":"GALLERY/#gallery_of_zplugin_invocations","text":"PRs welcomed :)","title":"Gallery Of Zplugin Invocations"},{"location":"GALLERY/#programs","text":"zplugin ice from\"gh-r\" as\"program\" zplugin light junegunn/fzf-bin zplugin ice from\"gh-r\" as\"program\" mv\"docker* -> docker-compose\" zplugin light docker/compose zplugin ice as\"program\" atclone\"rm -f src/auto/config.cache; ./configure\" \\ atpull\"%atclone\" make pick\"src/vim\" zplugin light vim/vim zplugin ice as\"program\" make'!' atclone'./direnv hook zsh > zhook.zsh' \\ atpull'%atclone' src\"zhook.zsh\" zplugin light direnv/direnv zplugin ice from\"gh-r\" as\"program\" mv\"direnv* -> direnv\" zplugin light direnv/direnv zplugin ice from\"gh-r\" as\"program\" mv\"shfmt* -> shfmt\" zplugin light mvdan/sh zplugin ice from\"gh-r\" as\"program\" mv\"gotcha_* -> gotcha\" zplugin light b4b4r07/gotcha zplugin ice as\"program\" pick\"yank\" make zplugin light mptre/yank zplugin ice wait\"2\" lucid as'command' pick'src/vramsteg' \\ atclone'cmake .' atpull'%atclone' make # use Turbo mode zplugin light psprint/vramsteg-zsh zplugin ice atclone\"./libexec/pyenv init - > zpyenv.zsh\" \\ atinit'export PYENV_ROOT=\"$PWD\"' atpull\"%atclone\" \\ as'command' pick'bin/pyenv' src\"zpyenv.zsh\" nocompile'!' zplugin light pyenv/pyenv zplugin ice as\"program\" pick\"$ZPFX/sdkman/bin/sdk\" id-as'sdkman' run-atpull \\ atclone\"wget https://get.sdkman.io -O scr.sh; SDKMAN_DIR=$ZPFX/sdkman bash scr.sh\" \\ atpull\"SDKMAN_DIR=$ZPFX/sdkman sdk selfupdate\" \\ atinit\"export SDKMAN_DIR=$ZPFX/sdkman; source $ZPFX/sdkman/bin/sdkman-init.sh\" zplugin light zdharma/null","title":"Programs"},{"location":"GALLERY/#completions","text":"zplugin ice as\"completion\" zplugin snippet https://github.com/docker/cli/blob/master/contrib/completion/zsh/_docker","title":"Completions"},{"location":"GALLERY/#scripts","text":"# For GNU ls (the binaries can be gls, gdircolors, e.g. on OS X when installing the # coreutils package from Homebrew or using https://github.com/ogham/exa) zplugin ice atclone\"dircolors -b LS_COLORS > c.zsh\" \\ atpull'%atclone' pick\"c.zsh\" nocompile'!' \\ atload'zstyle \":completion:*\" list-colors \u201c${(s.:.)LS_COLORS}\u201d' # Style the Zsh completion zplugin light trapd00r/LS_COLORS zplugin ice as\"program\" pick\"$ZPFX/bin/git-*\" make\"PREFIX=$ZPFX\" nocompile zplugin light tj/git-extras zplugin ice as\"program\" atclone'perl Makefile.PL PREFIX=$ZPFX' \\ atpull'%atclone' make'install' pick\"$ZPFX/bin/git-cal\" zplugin light k4rthik/git-cal zplugin ice as\"program\" id-as\"git-unique\" pick\"git-unique\" zplugin snippet https://github.com/Osse/git-scripts/blob/master/git-unique zplugin ice as\"program\" cp\"wd.sh -> wd\" mv\"_wd.sh -> _wd\" \\ atpull'!git reset --hard' pick\"wd\" zplugin light mfaerevaag/wd zplugin ice as\"program\" pick\"bin/archey\" zplugin load obihann/archey-osx","title":"Scripts"},{"location":"GALLERY/#plugins","text":"zplugin ice pick\"h.sh\" zplugin light paoloantinori/hhighlighter","title":"Plugins"},{"location":"GALLERY/#snippets","text":"zplugin ice svn pick\"completion.zsh\" src\"git.zsh\" zplugin snippet OMZ::lib zplugin ice svn wait\"0\" lucid atinit\"local ZSH=\\$PWD\" \\ atclone\"mkdir -p plugins; cd plugins; ln -sfn ../. osx\" zplugin snippet OMZ::plugins/osx # Or with most recent Zplugin and with ~/.zplugin/snippets # directory pruned (rm -rf -- ${ZPLGM[SNIPPETS_DIR]}): zplugin ice svn zplugin snippet OMZ::plugins/osx","title":"Snippets"},{"location":"GALLERY/#themes","text":"GEOMETRY_COLOR_DIR=152 zplugin ice wait\"0\" lucid atload\"geometry::prompt\" zplugin light geometry-zsh/geometry zplugin ice pick\"async.zsh\" src\"pure.zsh\" zplugin light sindresorhus/pure zplugin light mafredri/zsh-async # dependency zplugin ice svn silent atload'prompt sorin' zplugin snippet PZT::modules/prompt zplugin ice atload\"fpath+=( \\$PWD );\" zplugin light chauncey-garrett/zsh-prompt-garrett zplugin ice svn atload\"prompt garrett\" silent zplugin snippet PZT::modules/prompt zplugin ice nocompletions compile\"{zinc_functions/*,segments/*,zinc.zsh}\" zplugin load robobenklein/zinc # ZINC git info is already async, but if you want it # even faster with gitstatus in Turbo mode: # https://github.com/romkatv/gitstatus zplugin ice wait'1' atload'zinc_optional_depenency_loaded' zplugin load romkatv/gitstatus # After finishing the configuration wizard change the atload'' ice to: # -> atload'source ~/.p10k.zsh; _p9k_precmd' zplugin ice wait'!' lucid atload'true; _p9k_precmd' nocd zplugin light romkatv/powerlevel10k","title":"Themes"},{"location":"INTRODUCTION/","text":"Introduction # In the document below you\u2019ll find out how to: use Oh My Zsh and Prezto, manage completions, use the Turbo mode, use the ice-mods like as\"program\" , and much more. Basic Plugin Loading # zplugin load zdharma/history-search-multi-word zplugin light zsh-users/zsh-syntax-highlighting Above commands show two ways of basic plugin loading. load causes reporting to be enabled \u2013 you can track what plugin does, view the information with zplugin report {plugin-spec} and then also unload the plugin with zplugin unload {plugin-spec} . light is a significantly faster loading without tracking and reporting, by using which user resigns of the ability to view the plugin report and to unload it. Note In Turbo mode the slowdown caused by tracking is negligible. Oh My Zsh, Prezto # To load Oh My Zsh and Prezto plugins, use snippet feature. Snippets are single files downloaded by curl , wget , etc. (an automatic detection of the download tool is being performed) directly from URL. For example: zplugin snippet 'https://github.com/robbyrussell/oh-my-zsh/raw/master/plugins/git/git.plugin.zsh' zplugin snippet 'https://github.com/sorin-ionescu/prezto/blob/master/modules/helper/init.zsh' Also, for Oh My Zsh and Prezto, you can use OMZ:: and PZT:: shorthands: zplugin snippet OMZ::plugins/git/git.plugin.zsh zplugin snippet PZT::modules/helper/init.zsh Moreover, snippets support Subversion protocol, supported also by Github. This allows to load snippets that are multi-file (for example a Prezto module can consist of two or more files, e.g. init.zsh and alias.zsh ). Default files that will be sourced are: *.plugin.zsh , init.zsh , *.zsh-theme : # URL points to directory zplugin ice svn zplugin snippet PZT::modules/docker Snippets and Performance # Using curl , wget , etc. along with Subversion allows to almost completely avoid code dedicated to Oh My Zsh and Prezto, and also to other frameworks. This gives profits in performance of Zplugin , it is really fast and also compact (causing low memory footprint and short loading time). Some Ice-Modifiers # The command zplugin ice provides Ice-modifiers for single next command (see the README subsection ice-modifiers ). The logic is that \"ice\" is something something that\u2019s added (e.g. to a drink or a coffee) \u2013 and in the Zplugin sense this means that ice is a modifier added to the next Zplugin command, and also something that melts (so it doesn\u2019t last long) \u2013 and in the Zplugin use it means that the modifier lasts for only single next Zplugin command. Using one other Ice-modifier \" pick \" user can explicitly select the file to source : zplugin ice svn pick\"init.zsh\" zplugin snippet PZT::modules/git Content of Ice-modifier is simply put into \"\u2026\" , '\u2026' , or $'\u2026' . No need for \":\" after Ice-mod name (although it's allowed, so as the equal sign = , so e.g. pick=\"init.zsh\" or pick=init.zsh are being correctly recognized) . This way editors like vim and emacs and also zsh-users/zsh-syntax-highlighting and zdharma/fast-syntax-highlighting will highlight contents of Ice-modifiers. as\"program\" # A plugin might not be a file for sourcing, but a command to be added to $PATH . To obtain this effect, use Ice-modifier as with value program (or an alias value command ). zplugin ice as\"program\" cp\"httpstat.sh -> httpstat\" pick\"httpstat\" zplugin light b4b4r07/httpstat Above command will add plugin directory to $PATH , copy file httpstat.sh into httpstat and add execution rights ( +x ) to the file selected with pick , i.e. to httpstat . Other Ice-mod exists, mv , which works like cp but moves a file instead of copying it. mv is ran before cp . Note The cp and mv ices (and also as some other ones, like atclone ) are being run when the plugin or snippet is being installed . To test them again first delete the plugin or snippet by zplugin delete PZT::modules/osx (for example). atpull\"\u2026\" # Copying file is safe for doing later updates \u2013 original files of repository are unmodified and Git will report no conflicts. However, mv also can be used, if a proper atpull (an Ice\u2013modifier ran at update of plugin) will be used: zplugin ice as\"program\" mv\"httpstat.sh -> httpstat\" \\ pick\"httpstat\" atpull'!git reset --hard' zplugin light b4b4r07/httpstat If atpull starts with exclamation mark, then it will be run before git pull , and before mv . Nevertheless, atpull , mv , cp are ran only if new commits are to be fetched . So in summary, when user runs zplugin update b4b4r07/httpstat to update this plugin, and there are new commits, what happens first is that git reset --hard is ran \u2013 and it restores original httpstat.sh , then git pull is ran and it downloads new commits (doing fast-forward), then mv is ran again so that the command is httpstat not httpstat.sh . This way the mv ice can be used to induce a permanent changes into the plugin's contents without blocking the ability to update it with git (or with subversion in case of snippets, more on this below at ** ). Note For exclamation mark to not be expanded by Zsh in interactive session, use '\u2026' not \"\u2026\" to enclose contents of atpull Ice-mod. Snippets-Commands # Commands can also be added to $PATH using snippets . For example: zplugin ice mv\"httpstat.sh -> httpstat\" \\ pick\"httpstat\" as\"program\" zplugin snippet \\ https://github.com/b4b4r07/httpstat/blob/master/httpstat.sh ( ** ) Snippets also support atpull Ice-mod, so it\u2019s possible to do e.g. atpull'!svn revert' . There\u2019s also atinit Ice-mod, executed before each loading of plugin or snippet. Snippets-Completions # By using the as'' ice-mod with value completion you can point the snippet subcommand directly to a completion file, e.g.: zplugin ice as\"completion\" zplugin snippet https://github.com/docker/cli/blob/master/contrib/completion/zsh/_docker Completion Management # Zplugin allows to disable and enable each completion in every plugin. Try installing a popular plugin that provides completions: zplugin ice blockf zplugin light zsh-users/zsh-completions First command (the blockf ice) will block the traditional method of adding completions. Zplugin uses own method (based on symlinks instead of adding a number of directories to $fpath ). Zplugin will automatically install completions of a newly downloaded plugin. To uninstall the completions and install them again, you would use: zplugin cuninstall zsh-users/zsh-completions # uninstall zplugin creinstall zsh-users/zsh-completions # install Listing Completions # Note zplg is an alias that can be used in interactive sessions. To see what completions all plugins provide, in tabular formatting and with name of each plugin, use: zplg clist This command is specially adapted for plugins like zsh-users/zsh-completions , which provide many completions \u2013 listing will have 3 completions per line (so that a smaller number of terminal pages will be occupied) like this: ... atach, bitcoin-cli, bower zsh-users/zsh-completions bundle, caffeinate, cap zsh-users/zsh-completions cask, cf, chattr zsh-users/zsh-completions ... You can show more completions per line by providing an argument to clist , e.g. zplg clist 6 , will show: ... bundle, caffeinate, cap, cask, cf, chattr zsh-users/zsh-completions cheat, choc, cmake, coffee, column, composer zsh-users/zsh-completions console, dad, debuild, dget, dhcpcd, diana zsh-users/zsh-completions ... Enabling and Disabling Completions # Completions can be disabled, so that e.g. original Zsh completion will be used. The commands are very basic, they only need completion name : $ zplg cdisable cmake Disabled cmake completion belonging to zsh-users/zsh-completions $ zplg cenable cmake Enabled cmake completion belonging to zsh-users/zsh-completions That\u2019s all on completions. There\u2019s one more command, zplugin csearch , that will search all plugin directories for available completions, and show if they are installed: This sums up to complete control over completions. Subversion for Subdirectories # In general, to use subdirectories of Github projects as snippets add /trunk/{path-to-dir} to URL, for example: zplugin ice svn zplugin snippet https://github.com/zsh-users/zsh-completions/trunk/src # For Oh My Zsh and Prezto, the OMZ:: and PZT:: prefixes work # without the need to add the `/trunk/` infix (however the path # should point to a directory, not to a file): zplugin ice svn; zplugin snippet PZT::modules/docker Snippets too have completions installed by default, like plugins. Turbo Mode (Zsh >= 5.3) # The Ice-mod wait allows you to postpone loading of a plugin to the moment when processing of .zshrc is finished and prompt is being shown. It is like Windows \u2013 during startup, it shows desktop even though it still loads data in background. This has drawbacks, but is for sure better than blank screen for 10 minutes. And here, in Zplugin, there are no drawbacks of this approach \u2013 no lags, freezes, etc. \u2013 the command line is fully usable while the plugins are being loaded, for number of such plugins like 10 or 20 . Note Turbo mode will speed up Zsh startup by 50%\u201373% . For example instead of 200 ms, it'll be 50 ms (!) Zsh 5.3 or greater is required. To use this Turbo mode add wait ice to the target plugin in one of following ways: PS1=\"READY > \" zplugin ice wait'!0' atload'promptinit; prompt scala3' zplugin load psprint/zprompts This sets plugin psprint/zprompts to be loaded 0 seconds after zshrc . It will fire up after c.a. 1 ms of showing of the basic prompt READY > . I\u2019ve started to use this method of setting up a prompt 2 years ago now and I run it without any problems. It is also sufficient to provide just the word wait , it\u2019ll work like wait'0' (and wait'!' like wait'!0' ). The exclamation mark causes Zplugin to reset-prompt after loading plugin. The same with Prezto prompts, with a longer delay: zplg ice svn silent wait'!1' atload'prompt smiley' zplg snippet PZT::modules/prompt Using zsh-users/zsh-autosuggestions without any drawbacks: zplugin ice wait atload'_zsh_autosuggest_start' zplugin light zsh-users/zsh-autosuggestions Explanation: Autosuggestions uses precmd hook, which is being called right after processing zshrc (right before the first prompt). Turbo mode will wait 1 second after that, so precmd will not be installed and thus not called at that first prompt. This makes autosuggestions inactive at the first prompt. However the given atload Ice-mod fixes this, it calls the same function that precmd would, right after loading autosuggestions, resulting in exactly the same behavior of the plugin. zplugin ice wait'[[ -n ${ZLAST_COMMANDS[(r)cras*]} ]]' zplugin load zdharma/zplugin-crasis The plugin zplugin-crasis provides command crasis . Ice-mod wait is set to wait on condition . When user enters cras at command line, the plugin will be loaded within 1 second and command crasis will become available. See the feature in action . This feature requires zdharma/fast-syntax-highlighting (it builds the ZLAST_COMMANDS array). Automatic Load/Unload on Condition # Ices load and unload allow to define when you want plugins active or unactive. For example: # Load when in ~/tmp zplugin ice load'![[ $PWD = */tmp* ]]' unload'![[ $PWD != */tmp* ]]' \\ atload\"promptinit; prompt sprint3\" zplugin load psprint/zprompts # Load when NOT in ~/tmp zplugin ice load'![[ $PWD != */tmp* ]]' unload'![[ $PWD = */tmp* ]]' zplugin load russjohnson/angry-fly-zsh Two prompts, each active in different directories. This technique can be used to have plugin-sets, e.g. by defining parameter $PLUGINS with possible values like cpp , web , admin and by setting load / unload conditions to activate different plugins on cpp , on web , etc. Note The difference with wait is that load / unload are constantly active, not only till first activation. Note that for unloading of a plugin to work the plugin needs to be loaded with tracking (so zplugin load \u2026 , not zplugin light \u2026 ). Tracking causes slight slowdown, however this doesn\u2019t influence Zsh startup time when using Turbo mode. See also Wiki on multiple prompts .","title":"Introduction"},{"location":"INTRODUCTION/#introduction","text":"In the document below you\u2019ll find out how to: use Oh My Zsh and Prezto, manage completions, use the Turbo mode, use the ice-mods like as\"program\" , and much more.","title":"Introduction"},{"location":"INTRODUCTION/#basic_plugin_loading","text":"zplugin load zdharma/history-search-multi-word zplugin light zsh-users/zsh-syntax-highlighting Above commands show two ways of basic plugin loading. load causes reporting to be enabled \u2013 you can track what plugin does, view the information with zplugin report {plugin-spec} and then also unload the plugin with zplugin unload {plugin-spec} . light is a significantly faster loading without tracking and reporting, by using which user resigns of the ability to view the plugin report and to unload it. Note In Turbo mode the slowdown caused by tracking is negligible.","title":"Basic Plugin Loading"},{"location":"INTRODUCTION/#oh_my_zsh_prezto","text":"To load Oh My Zsh and Prezto plugins, use snippet feature. Snippets are single files downloaded by curl , wget , etc. (an automatic detection of the download tool is being performed) directly from URL. For example: zplugin snippet 'https://github.com/robbyrussell/oh-my-zsh/raw/master/plugins/git/git.plugin.zsh' zplugin snippet 'https://github.com/sorin-ionescu/prezto/blob/master/modules/helper/init.zsh' Also, for Oh My Zsh and Prezto, you can use OMZ:: and PZT:: shorthands: zplugin snippet OMZ::plugins/git/git.plugin.zsh zplugin snippet PZT::modules/helper/init.zsh Moreover, snippets support Subversion protocol, supported also by Github. This allows to load snippets that are multi-file (for example a Prezto module can consist of two or more files, e.g. init.zsh and alias.zsh ). Default files that will be sourced are: *.plugin.zsh , init.zsh , *.zsh-theme : # URL points to directory zplugin ice svn zplugin snippet PZT::modules/docker","title":"Oh My Zsh, Prezto"},{"location":"INTRODUCTION/#snippets_and_performance","text":"Using curl , wget , etc. along with Subversion allows to almost completely avoid code dedicated to Oh My Zsh and Prezto, and also to other frameworks. This gives profits in performance of Zplugin , it is really fast and also compact (causing low memory footprint and short loading time).","title":"Snippets and Performance"},{"location":"INTRODUCTION/#some_ice-modifiers","text":"The command zplugin ice provides Ice-modifiers for single next command (see the README subsection ice-modifiers ). The logic is that \"ice\" is something something that\u2019s added (e.g. to a drink or a coffee) \u2013 and in the Zplugin sense this means that ice is a modifier added to the next Zplugin command, and also something that melts (so it doesn\u2019t last long) \u2013 and in the Zplugin use it means that the modifier lasts for only single next Zplugin command. Using one other Ice-modifier \" pick \" user can explicitly select the file to source : zplugin ice svn pick\"init.zsh\" zplugin snippet PZT::modules/git Content of Ice-modifier is simply put into \"\u2026\" , '\u2026' , or $'\u2026' . No need for \":\" after Ice-mod name (although it's allowed, so as the equal sign = , so e.g. pick=\"init.zsh\" or pick=init.zsh are being correctly recognized) . This way editors like vim and emacs and also zsh-users/zsh-syntax-highlighting and zdharma/fast-syntax-highlighting will highlight contents of Ice-modifiers.","title":"Some Ice-Modifiers"},{"location":"INTRODUCTION/#asprogram","text":"A plugin might not be a file for sourcing, but a command to be added to $PATH . To obtain this effect, use Ice-modifier as with value program (or an alias value command ). zplugin ice as\"program\" cp\"httpstat.sh -> httpstat\" pick\"httpstat\" zplugin light b4b4r07/httpstat Above command will add plugin directory to $PATH , copy file httpstat.sh into httpstat and add execution rights ( +x ) to the file selected with pick , i.e. to httpstat . Other Ice-mod exists, mv , which works like cp but moves a file instead of copying it. mv is ran before cp . Note The cp and mv ices (and also as some other ones, like atclone ) are being run when the plugin or snippet is being installed . To test them again first delete the plugin or snippet by zplugin delete PZT::modules/osx (for example).","title":"as\"program\""},{"location":"INTRODUCTION/#atpull","text":"Copying file is safe for doing later updates \u2013 original files of repository are unmodified and Git will report no conflicts. However, mv also can be used, if a proper atpull (an Ice\u2013modifier ran at update of plugin) will be used: zplugin ice as\"program\" mv\"httpstat.sh -> httpstat\" \\ pick\"httpstat\" atpull'!git reset --hard' zplugin light b4b4r07/httpstat If atpull starts with exclamation mark, then it will be run before git pull , and before mv . Nevertheless, atpull , mv , cp are ran only if new commits are to be fetched . So in summary, when user runs zplugin update b4b4r07/httpstat to update this plugin, and there are new commits, what happens first is that git reset --hard is ran \u2013 and it restores original httpstat.sh , then git pull is ran and it downloads new commits (doing fast-forward), then mv is ran again so that the command is httpstat not httpstat.sh . This way the mv ice can be used to induce a permanent changes into the plugin's contents without blocking the ability to update it with git (or with subversion in case of snippets, more on this below at ** ). Note For exclamation mark to not be expanded by Zsh in interactive session, use '\u2026' not \"\u2026\" to enclose contents of atpull Ice-mod.","title":"atpull\"\u2026\""},{"location":"INTRODUCTION/#snippets-commands","text":"Commands can also be added to $PATH using snippets . For example: zplugin ice mv\"httpstat.sh -> httpstat\" \\ pick\"httpstat\" as\"program\" zplugin snippet \\ https://github.com/b4b4r07/httpstat/blob/master/httpstat.sh ( ** ) Snippets also support atpull Ice-mod, so it\u2019s possible to do e.g. atpull'!svn revert' . There\u2019s also atinit Ice-mod, executed before each loading of plugin or snippet.","title":"Snippets-Commands"},{"location":"INTRODUCTION/#snippets-completions","text":"By using the as'' ice-mod with value completion you can point the snippet subcommand directly to a completion file, e.g.: zplugin ice as\"completion\" zplugin snippet https://github.com/docker/cli/blob/master/contrib/completion/zsh/_docker","title":"Snippets-Completions"},{"location":"INTRODUCTION/#completion_management","text":"Zplugin allows to disable and enable each completion in every plugin. Try installing a popular plugin that provides completions: zplugin ice blockf zplugin light zsh-users/zsh-completions First command (the blockf ice) will block the traditional method of adding completions. Zplugin uses own method (based on symlinks instead of adding a number of directories to $fpath ). Zplugin will automatically install completions of a newly downloaded plugin. To uninstall the completions and install them again, you would use: zplugin cuninstall zsh-users/zsh-completions # uninstall zplugin creinstall zsh-users/zsh-completions # install","title":"Completion Management"},{"location":"INTRODUCTION/#listing_completions","text":"Note zplg is an alias that can be used in interactive sessions. To see what completions all plugins provide, in tabular formatting and with name of each plugin, use: zplg clist This command is specially adapted for plugins like zsh-users/zsh-completions , which provide many completions \u2013 listing will have 3 completions per line (so that a smaller number of terminal pages will be occupied) like this: ... atach, bitcoin-cli, bower zsh-users/zsh-completions bundle, caffeinate, cap zsh-users/zsh-completions cask, cf, chattr zsh-users/zsh-completions ... You can show more completions per line by providing an argument to clist , e.g. zplg clist 6 , will show: ... bundle, caffeinate, cap, cask, cf, chattr zsh-users/zsh-completions cheat, choc, cmake, coffee, column, composer zsh-users/zsh-completions console, dad, debuild, dget, dhcpcd, diana zsh-users/zsh-completions ...","title":"Listing Completions"},{"location":"INTRODUCTION/#enabling_and_disabling_completions","text":"Completions can be disabled, so that e.g. original Zsh completion will be used. The commands are very basic, they only need completion name : $ zplg cdisable cmake Disabled cmake completion belonging to zsh-users/zsh-completions $ zplg cenable cmake Enabled cmake completion belonging to zsh-users/zsh-completions That\u2019s all on completions. There\u2019s one more command, zplugin csearch , that will search all plugin directories for available completions, and show if they are installed: This sums up to complete control over completions.","title":"Enabling and Disabling Completions"},{"location":"INTRODUCTION/#subversion_for_subdirectories","text":"In general, to use subdirectories of Github projects as snippets add /trunk/{path-to-dir} to URL, for example: zplugin ice svn zplugin snippet https://github.com/zsh-users/zsh-completions/trunk/src # For Oh My Zsh and Prezto, the OMZ:: and PZT:: prefixes work # without the need to add the `/trunk/` infix (however the path # should point to a directory, not to a file): zplugin ice svn; zplugin snippet PZT::modules/docker Snippets too have completions installed by default, like plugins.","title":"Subversion for Subdirectories"},{"location":"INTRODUCTION/#turbo_mode_zsh_62_53","text":"The Ice-mod wait allows you to postpone loading of a plugin to the moment when processing of .zshrc is finished and prompt is being shown. It is like Windows \u2013 during startup, it shows desktop even though it still loads data in background. This has drawbacks, but is for sure better than blank screen for 10 minutes. And here, in Zplugin, there are no drawbacks of this approach \u2013 no lags, freezes, etc. \u2013 the command line is fully usable while the plugins are being loaded, for number of such plugins like 10 or 20 . Note Turbo mode will speed up Zsh startup by 50%\u201373% . For example instead of 200 ms, it'll be 50 ms (!) Zsh 5.3 or greater is required. To use this Turbo mode add wait ice to the target plugin in one of following ways: PS1=\"READY > \" zplugin ice wait'!0' atload'promptinit; prompt scala3' zplugin load psprint/zprompts This sets plugin psprint/zprompts to be loaded 0 seconds after zshrc . It will fire up after c.a. 1 ms of showing of the basic prompt READY > . I\u2019ve started to use this method of setting up a prompt 2 years ago now and I run it without any problems. It is also sufficient to provide just the word wait , it\u2019ll work like wait'0' (and wait'!' like wait'!0' ). The exclamation mark causes Zplugin to reset-prompt after loading plugin. The same with Prezto prompts, with a longer delay: zplg ice svn silent wait'!1' atload'prompt smiley' zplg snippet PZT::modules/prompt Using zsh-users/zsh-autosuggestions without any drawbacks: zplugin ice wait atload'_zsh_autosuggest_start' zplugin light zsh-users/zsh-autosuggestions Explanation: Autosuggestions uses precmd hook, which is being called right after processing zshrc (right before the first prompt). Turbo mode will wait 1 second after that, so precmd will not be installed and thus not called at that first prompt. This makes autosuggestions inactive at the first prompt. However the given atload Ice-mod fixes this, it calls the same function that precmd would, right after loading autosuggestions, resulting in exactly the same behavior of the plugin. zplugin ice wait'[[ -n ${ZLAST_COMMANDS[(r)cras*]} ]]' zplugin load zdharma/zplugin-crasis The plugin zplugin-crasis provides command crasis . Ice-mod wait is set to wait on condition . When user enters cras at command line, the plugin will be loaded within 1 second and command crasis will become available. See the feature in action . This feature requires zdharma/fast-syntax-highlighting (it builds the ZLAST_COMMANDS array).","title":"Turbo Mode (Zsh >= 5.3)"},{"location":"INTRODUCTION/#automatic_loadunload_on_condition","text":"Ices load and unload allow to define when you want plugins active or unactive. For example: # Load when in ~/tmp zplugin ice load'![[ $PWD = */tmp* ]]' unload'![[ $PWD != */tmp* ]]' \\ atload\"promptinit; prompt sprint3\" zplugin load psprint/zprompts # Load when NOT in ~/tmp zplugin ice load'![[ $PWD != */tmp* ]]' unload'![[ $PWD = */tmp* ]]' zplugin load russjohnson/angry-fly-zsh Two prompts, each active in different directories. This technique can be used to have plugin-sets, e.g. by defining parameter $PLUGINS with possible values like cpp , web , admin and by setting load / unload conditions to activate different plugins on cpp , on web , etc. Note The difference with wait is that load / unload are constantly active, not only till first activation. Note that for unloading of a plugin to work the plugin needs to be loaded with tracking (so zplugin load \u2026 , not zplugin light \u2026 ). Tracking causes slight slowdown, however this doesn\u2019t influence Zsh startup time when using Turbo mode. See also Wiki on multiple prompts .","title":"Automatic Load/Unload on Condition"},{"location":"Installing-with-make/","text":"zplugin ice as\"program\" pick\"$ZPFX/bin/git-*\" make\"PREFIX=$ZPFX\" zplugin light tj/git-extras Makefile of this project has only one needed target \u2013 install , which is called by default, it also does building of the scripts that it installs, so it does 2 tasks, for Makefile with 2 targets, one could use make\"all install PREFIX=\u2026\" , pick'\u2026' will chmod +x all matching files and add $ZPFX/bin/ to $PATH , $ZPFX is provided by Zplugin, it is ~/.zplugin/polaris by default, can be also customized. Below is a hard core but fully working method of managing a software ( sdkman.io ) with Zplugin. # The invocation uses https://github.com/zdharma/null repo as a placeholder # for the atclone'' and atpull'' hooks zplugin ice as\"program\" pick\"$ZPFX/sdkman/bin/sdk\" id-as'sdkman' run-atpull \\ atclone\"wget https://get.sdkman.io -O scr.sh; SDKMAN_DIR=$ZPFX/sdkman bash scr.sh\" \\ atpull\"SDKMAN_DIR=$ZPFX/sdkman sdk selfupdate\" \\ atinit\"export SDKMAN_DIR=$ZPFX/sdkman; source $ZPFX/sdkman/bin/sdkman-init.sh\" zplugin light zdharma/null","title":"Installing With Make"},{"location":"LS_COLORS-explanation/","text":"A repository trapd00r/LS_COLORS provides a file with color definitions for GNU ls command (and also for ogham/exa ; it can be also used to style Zsh completion \u2013 more on this below). Typically one does eval $( dircolors -b $HOME/LS_COLORS) to process this file and set environment for ls . However this means dircolors is ran every shell startup. This costs much time, because a fork has to be done and the program (i.e. dircolors ) binary needs to be loaded and executed, and because dircolors loads the colors' definitions and processes them. Following Zplugin invocation solves this problem: zplugin ice atclone\"dircolors -b LS_COLORS > clrs.zsh\" \\ atpull'%atclone' pick\"clrs.zsh\" nocompile'!' \\ atload'zstyle \":completion:*\" list-colors \u201c${(s.:.)LS_COLORS}\u201d' zplugin light trapd00r/LS_COLORS atclone\"\u2026\" \u2013 generate shell script, but instead of passing it to eval , save it to file, atpull'%atclone' \u2013 do the same at any update of plugin (the atclone is being ran on the installation while the atpull hook is being ran on an update of the trapd00r/LS_COLORS plugin); the %atclone is just a special string that denotes that the atclone'' hook should be copied onto the atpull'' hook, pick\"clrs.zsh\" \u2013 source file clrs.zsh , the one that is generated, nocompile'!' \u2013 invokes compilation after the atclone'' ice-mod (the exclamation mark causes this). atload\"\u2026\" \u2013 additionally sets up the Zsh completion to use the colors provided by the trapd00r package. This way, except for the plugin installation and update, dircolors isn't ran, just normal sourcing is done. The every-day sourced file (i.e. c.zsh ) is even being compiled to speed up the loading.","title":"LS_COLORS Explanation"},{"location":"Multiple-prompts/","text":"# Load when MYPROMPT == 1 zplugin ice load'![[ $MYPROMPT = 1 ]]' unload'![[ $MYPROMPT != 1 ]]' zplugin load halfo/lambda-mod-zsh-theme # Load when MYPROMPT == 2 zplugin ice load'![[ $MYPROMPT = 2 ]]' unload'![[ $MYPROMPT != 2 ]]' \\ pick\"/dev/null\" multisrc\"{async,pure}.zsh\" zplugin load sindresorhus/pure # Load when MYPROMPT == 3 zplugin ice load'![[ $MYPROMPT = 3 ]]' unload'![[ $MYPROMPT != 3 ]]' zplugin load geometry-zsh/geometry load'' \u2013 condition that when fulfilled will cause plugin to be loaded, unload'' \u2013 as above, but will unload plugin, note that plugins are loaded with zplugin load , not zplugin light , to track what plugin does, to be able to unload it, conditions are checked every second, you can use conditions like ![[ $PWD == *github* ]] to change prompt after changing directory to *github* , the exclamation mark ![[ \u2026 ]] causes prompt to be reset after loading or unloading the plugin, pick'/dev/null' \u2013 disable sourcing of the default-found file multisrc'' \u2013 source multiple files","title":"Multiple Prompts"},{"location":"Profiling-plugins/","text":"zplugin ice atinit'zmodload zsh/zprof' \\ atload'zprof | head -n 20; zmodload -u zsh/zprof' zplugin light zdharma/fast-syntax-highlighting atinit'' loads zsh/zprof module (shipped with Zsh) before loading the plugin \u2013 this starts the profiling, atload'' works after loading the plugin \u2013 shows profiling results ( zprof | head ), unloads zsh/zprof - this stops the profiling; in the effect, only a single plugin (in this case zdharma/fast-syntax-highlighting ) will be profiled while the rest of the e.g. zshrc processing will go on completely normally, the light loads without reporting enabled, so less Zplugin code is being run \u2013 no Zplugin code responsible for the tracking (i.e. the automatic data gathering, during loading of a plugin, for the reports and the possibility to unload the plugin) will be activated and the functions will not appear in the zprof report. example zprof report: num calls time self name --------------------------------------------------------------------------- 1) 1 57,76 57,76 57,91% 57,76 57,76 57,91% _zsh_highlight_bind_widgets 2) 1 25,81 25,81 25,88% 25,81 25,81 25,88% compinit 3) 4 10,71 2,68 10,74% 8,71 2,18 8,73% --zplg-shadow-autoload 4) 43 2,06 0,05 2,07% 2,06 0,05 2,07% -zplg-add-report 5) 8 1,98 0,25 1,98% 1,98 0,25 1,98% compdef 6) 1 2,85 2,85 2,85% 0,87 0,87 0,87% -zplg-compdef-replay 7) 1 0,68 0,68 0,68% 0,68 0,68 0,68% -zplg-shadow-off 8) 1 0,79 0,79 0,79% 0,49 0,49 0,49% add-zsh-hook 9) 1 0,47 0,47 0,47% 0,47 0,47 0,47% -zplg-shadow-on 10) 3 0,34 0,11 0,35% 0,34 0,11 0,35% (anon) 11) 4 10,91 2,73 10,94% 0,20 0,05 0,20% autoload 12) 1 0,19 0,19 0,19% 0,19 0,19 0,19% -fast-highlight-fill-option-variables 13) 1 25,98 25,98 26,05% 0,17 0,17 0,17% zpcompinit 14) 1 2,88 2,88 2,89% 0,03 0,03 0,03% zpcdreplay 15) 1 0,00 0,00 0,00% 0,00 0,00 0,00% -zplg-load-plugin ----------------------------------------------------------------------------------- the first column is the time is in milliseconds; it denotes the amount of time spent in a function in total so for example, --zplg-shadow-autoload consumed 10.71 ms of the execution time, the fourth column is also a time in milliseconds, but it denotes the amount of time spent on executing only of function's own code , i.e. it doesn't count the time spent in descendant functions that are called from the function; so for example, --zplg-shadow-autoload spent 8.71 ms on executing only its own code. the table is sorted on the self-time column.","title":"Profiling Plugins"},{"location":"Sourcing-multiple-files/","text":"Normally src'' can be used to specify additional file to source: zplugin ice pick\"powerless.zsh\" src\"utilities.zsh\" zplugin light martinrotter/powerless pick'' \u2013 provide main file to source (can be a pattern like *.sh \u2013 alphabetically first matched file is sourced), src'' \u2013 provide second file to source (not a pattern, plain file name) However, via atload'' ice one can provide simple loop to source more files: zplugin ice svn pick\"completion.zsh\" \\ atload'local f; for f in git.zsh misc.zsh; do \\ source $f \\ done' zplugin snippet OMZ::lib svn \u2013 use Subversion to clone OMZ::lib (the whole Oh My Zsh lib/ directory), note that atload'' uses apostrophes not double quotes, to literally put $f into the string, atload 's code is automatically being run within the snippet's (or plugin's) directory , atload'' code isn't tracked by Zplugin, i.e. cannot be unloaded, unless you load a plugin (not a snippet) with zplugin load \u2026 and prepend the value of the ice with exclamation mark, i.e. atload'!local f; for \u2026' , atload'' is executed after loading main files ( pick'' and src'' ones). The multisrc'' ice, which loads multiple files enumerated with spaces as the separator (e.g. multisrc'misc.zsh grep.zsh' ) and also using brace-expansion syntax (e.g. multisrc'{misc,grep}.zsh') . Example: zplugin ice svn pick\"completion.zsh\" multisrc'git.zsh \\ functions.zsh {history,grep}.zsh' zplugin snippet OMZ::lib The all possible ways to use the multisrc'' ice-mod: zplugin ice depth\"1\" multisrc=\"lib/{functions,misc}.zsh\" pick\"/dev/null\" zplugin load robbyrussell/oh-my-zsh # Can use patterns zplugin ice svn multisrc\"{funct*,misc}.zsh\" pick\"/dev/null\" zplugin snippet OMZ::lib array=( {functions,misc}.zsh ) zplugin ice svn multisrc\"$array\" pick\"/dev/null\" zplugin snippet OMZ::lib # Will use the array's value at the moment of plugin load # \u2013 this can matter in case of using Turbo mode array=( {functions,misc}.zsh ) zplugin ice svn multisrc\"\\$array\" pick\"/dev/null\" zplugin snippet OMZ::lib # Compatible with KSH_ARRAYS option array=( {functions,misc}.zsh ) zplugin ice svn multisrc\"${array[*]}\" pick\"/dev/null\" zplugin snippet OMZ::lib # Compatible with KSH_ARRAYS option array=( {functions,misc}.zsh ) zplugin ice svn multisrc\"\\${array[*]}\" pick\"/dev/null\" zplugin snippet OMZ::lib zplugin ice svn multisrc\"misc.zsh functions.zsh\" pick\"/dev/null\" zplugin snippet OMZ::lib # Also \u2013 hack Zplugin: the ice's contents is simply `eval'-uated # like follows: eval \"reply=($multisrc)\". So it might get handy on # an occasion to pass code there, but first you must close the paren # and then don't forget to assign `reply', and to provide a trailing # opening paren. In the code be careful to not redefine any variable # used internally by Zplugin \u2013 e.g.: `i' is safe: array=( {functions,misc}.zsh ) zplugin ice svn multisrc'); local i; for i in $array; do \\ reply+=( ${i/.zsh/.sh} ); \\ done; ((1)' pick\"/dev/null\" zplugin snippet OMZ::lib","title":"Sourcing Multiple Files"},{"location":"Z-PLUGINS/","text":"z-plugins # What Are They? # They are Zplugin extensions. Note the difference in the name from the Zplugin \u2013 the dash and the plural form. What Can They Do? # Add a new Zplugin subcommand (i.e. the command that\u2019s placed after the function zplugin \u2026 when calling Zplugin). Add new ice-modifiers. Register four type of hooks: atclone hook \u2013 run after cloning any plugin or downloading any snippet. atpull hook \u2013 run after pulling new commits (i.e. updating) for any plugin / snippet. atinit hook \u2013 run before loading any plugin / snippet, after it has been set-up (i.e. downloaded). atload hook \u2013 run after loading any plugin / snippet. Register hooks for generating help text, shown by the zplugin help subcommand. How To Code Them? # Below is an example body of an atclone hook (taken from zdharma/z-p-submods z-plugin). It shows how to: Obtain the arguments passed to the hook. Use an ice modifier. It also shows an useful snippet that will trim the whitespace in array elements. Utilize the last hook argument \u2013 the plugin\u2019s/snippet\u2019s containing directory. emulate -L zsh -o extendedglob -o warncreateglobal -o typesetsilent [[ -z \"${ZPLG_ICE[submods]}\" ]] && return 0 # (1) [[ \"$1\" = plugin ]] && \\ local type=\"$1\" user=\"$2\" plugin=\"$3\" id_as=\"$4\" dir=\"$5\" || \\ local type=\"$1\" url=\"$2\" id_as=\"$3\" dir=\"$4\" # type: snippet local -a mods parts local mod # (2) mods=( ${(@s.;.)ZPLG_ICE[submods]} ) for mod in \"${mods[@]}\"; do parts=( \"${(@s:->:)mod}\" ) # (3) Remove only leading and trailing whitespace parts=( \"${parts[@]//((#s)[[:space:]]##|[[:space:]]##(#e))/}\" ) print \"\\nCloning submodule: ${parts[1]} to dir: ${parts[2]}\" parts[1]=\"https://github.com/${parts[1]}\" # (4) \u2013 the: -C \"$dir\" command git -C \"$dir\" clone --progress \"${parts[1]}\" \"${parts[2]}\" done The recommended method of creating a hook is to place its body into a file that starts with a colon, and also a zp- prefix, e.g. :zp-myproject-atclone-hook and then to mark it for autoloading via autoload -Uz :zp-myproject-atclone-hook . Then register the hook (presumably in the myproject.plugin.zsh file) with the API call: @zplg-register-z-plugin : @zplg-register-z-plugin \"myproject\" hook:atclone \\ :zp-myproject-atclone-handler \\ :zp-myproject-atclone-help-handler \\ \"submods''\" # register a new ice-mod: submods'' The general syntax of the API call is: @zplg-register-z-plugin {project-name} \\ {hook:<hook-type>|subcommand:<new-subcommand-name>} \\ {name-of-the-handler-function} \\ {name-of-the-HELP-handler-function} \\ \"{ice-mod1}|{ice-mod2}|\u2026\" The last argument, i.e. the | -separated ice-list, is optional. That\u2019s all! After this loading the plugin myproject will set up the new ice-mod submods that will have syntax submods'{user}/{plugin} \u2013> {output-dir}; \u2026' and will clone submodules when installing the original plugin or snippet! Example real-world use of the ice-mod: # Load the `zsh-autosuggestions' plugin via Prezto module: `autosuggestions' zplugin ice svn submods'zsh-users/zsh-autosuggestions -> external' zplugin snippet PZT::modules/autosuggestions Checkout the project which fully implements this idea, zdharma/z-p-submods . It e.g. also implements the atpull hook, i.e. supports automatic update of the submodules. The z-p-* prefix is recommended for projects that are being z-plugins. Details # There are 2 or 3 subtypes for each of the hook: atinit or !atinit \u2013 the ! version is ran before the atinit ice-mod (i.e. before zplugin ice atinit'echo this!'; \u2026 ), while the normal version runs after it. atload or !atload \u2013 analogous to the atinit case: the ! version runs before the atload ice-mod (while the normal version runs after it). atclone or !atclone \u2013 analogous to the atinit and atload cases. atpull , !atpull or %atpull \u2013 the first two are being ran only when there are new commits to be downloaded during the update. The % version is being always run, regardless if the update will pull any actual commits or not, and it is being ran after the atpull ice-mod .","title":"Z-Plugins"},{"location":"Z-PLUGINS/#z-plugins","text":"","title":"z-plugins"},{"location":"Z-PLUGINS/#what_are_they","text":"They are Zplugin extensions. Note the difference in the name from the Zplugin \u2013 the dash and the plural form.","title":"What Are They?"},{"location":"Z-PLUGINS/#what_can_they_do","text":"Add a new Zplugin subcommand (i.e. the command that\u2019s placed after the function zplugin \u2026 when calling Zplugin). Add new ice-modifiers. Register four type of hooks: atclone hook \u2013 run after cloning any plugin or downloading any snippet. atpull hook \u2013 run after pulling new commits (i.e. updating) for any plugin / snippet. atinit hook \u2013 run before loading any plugin / snippet, after it has been set-up (i.e. downloaded). atload hook \u2013 run after loading any plugin / snippet. Register hooks for generating help text, shown by the zplugin help subcommand.","title":"What Can They Do?"},{"location":"Z-PLUGINS/#how_to_code_them","text":"Below is an example body of an atclone hook (taken from zdharma/z-p-submods z-plugin). It shows how to: Obtain the arguments passed to the hook. Use an ice modifier. It also shows an useful snippet that will trim the whitespace in array elements. Utilize the last hook argument \u2013 the plugin\u2019s/snippet\u2019s containing directory. emulate -L zsh -o extendedglob -o warncreateglobal -o typesetsilent [[ -z \"${ZPLG_ICE[submods]}\" ]] && return 0 # (1) [[ \"$1\" = plugin ]] && \\ local type=\"$1\" user=\"$2\" plugin=\"$3\" id_as=\"$4\" dir=\"$5\" || \\ local type=\"$1\" url=\"$2\" id_as=\"$3\" dir=\"$4\" # type: snippet local -a mods parts local mod # (2) mods=( ${(@s.;.)ZPLG_ICE[submods]} ) for mod in \"${mods[@]}\"; do parts=( \"${(@s:->:)mod}\" ) # (3) Remove only leading and trailing whitespace parts=( \"${parts[@]//((#s)[[:space:]]##|[[:space:]]##(#e))/}\" ) print \"\\nCloning submodule: ${parts[1]} to dir: ${parts[2]}\" parts[1]=\"https://github.com/${parts[1]}\" # (4) \u2013 the: -C \"$dir\" command git -C \"$dir\" clone --progress \"${parts[1]}\" \"${parts[2]}\" done The recommended method of creating a hook is to place its body into a file that starts with a colon, and also a zp- prefix, e.g. :zp-myproject-atclone-hook and then to mark it for autoloading via autoload -Uz :zp-myproject-atclone-hook . Then register the hook (presumably in the myproject.plugin.zsh file) with the API call: @zplg-register-z-plugin : @zplg-register-z-plugin \"myproject\" hook:atclone \\ :zp-myproject-atclone-handler \\ :zp-myproject-atclone-help-handler \\ \"submods''\" # register a new ice-mod: submods'' The general syntax of the API call is: @zplg-register-z-plugin {project-name} \\ {hook:<hook-type>|subcommand:<new-subcommand-name>} \\ {name-of-the-handler-function} \\ {name-of-the-HELP-handler-function} \\ \"{ice-mod1}|{ice-mod2}|\u2026\" The last argument, i.e. the | -separated ice-list, is optional. That\u2019s all! After this loading the plugin myproject will set up the new ice-mod submods that will have syntax submods'{user}/{plugin} \u2013> {output-dir}; \u2026' and will clone submodules when installing the original plugin or snippet! Example real-world use of the ice-mod: # Load the `zsh-autosuggestions' plugin via Prezto module: `autosuggestions' zplugin ice svn submods'zsh-users/zsh-autosuggestions -> external' zplugin snippet PZT::modules/autosuggestions Checkout the project which fully implements this idea, zdharma/z-p-submods . It e.g. also implements the atpull hook, i.e. supports automatic update of the submodules. The z-p-* prefix is recommended for projects that are being z-plugins.","title":"How To Code Them?"},{"location":"Z-PLUGINS/#details","text":"There are 2 or 3 subtypes for each of the hook: atinit or !atinit \u2013 the ! version is ran before the atinit ice-mod (i.e. before zplugin ice atinit'echo this!'; \u2026 ), while the normal version runs after it. atload or !atload \u2013 analogous to the atinit case: the ! version runs before the atload ice-mod (while the normal version runs after it). atclone or !atclone \u2013 analogous to the atinit and atload cases. atpull , !atpull or %atpull \u2013 the first two are being ran only when there are new commits to be downloaded during the update. The % version is being always run, regardless if the update will pull any actual commits or not, and it is being ran after the atpull ice-mod .","title":"Details"},{"location":"atload-and-other-at-ices/","text":"The atload Ice (and other at\u2026 ices) # Introduction # There are four code-receiving ices: atclone , atpull , atinit , atload . Their role is to receive a portion of Zsh code and execute it in certain moments of the plugin life-cycle . The atclone executes it: after cloning the associated plugin or snippet to the disk. The atpull is similar, but works: after updating the associated plugin or snippet. Next, atinit works similar, but is being activated: before loading of the associated plugin or snippet. Last, atload is being activated: after loading of the associated plugin or snippet. For convenience, you can use each of the ices multiple times in single zplugin ice \u2026 invocation \u2013 all the passed commands will be executed in the given order. The atpull ice recognizes a special value: %atclone (so the code looks i.e.: atpull'%atclone' ). It causes the contents of the atclone ice to be copied into the contents of the atpull ice. This is handy when the same tasks have to be performed on clone and on update of plugin or snippet, like e.g.: in the Direnv example . Exclamation mark -preceded atload # The wrap-track ice allows to track and unload plugins that defer their initialization into a function run later after sourcing the plugin's script \u2013 when the function is called, the plugin is then being fully initialized. However, if the function is being called from the atload ice, then there is a simpler method than the wrap-track ice \u2013 an exclamation mark -preceded atload contents. The exclamation mark causes the effects of the execution of the code passed to atload ice to be recorded. Example # For example, in the following invocation: zplugin ice id-as'test' atload'!PATH+=:~/share' zplugin load zdharma/null the $PATH is being changed within atload ice. Zplugin's tracking records $PATH changes and withdraws them on plugin unload, and also shows information loading: $ zplg report test Report for test plugin ---------------------- Source (reporting enabled) PATH elements added: /home/sg/share As it can be seen, the atload code is being correctly tracked and can be unloaded & viewed. Below is the result of using the unload subcommand to unload the test plugin: $ zplugin unload test --- Unloading plugin: test --- Removing PATH element /home/sg/share Unregistering plugin test Plugin report saved to $LASTREPORT Practical example # The same example as in the Tracking precmd-based Plugins article, but using the exclamation mark -preceded atload instead of wrap-track : # Load when MYPROMPT == 4 zplugin ice load'![[ $MYPROMPT = 4 ]]' unload'![[ $MYPROMPT != 4 ]]' \\ atload'!source ~/.p10k.zsh; _p9k_precmd' zplugin load romkatv/powerlevel10k Summary # The creation of the four additional Zle-widgets will be recorded (see the article on wrap-track for more information) \u2013 the effect will be exactly the same as with the wrap-track ice. The widgets will be properly deleted/restored on the plugin unload with MYPROMPT=3 (for example) and the shell state will be clean, ready to load a new prompt.","title":"Tracking precmd-based Plugins (2)"},{"location":"atload-and-other-at-ices/#the_atload_ice_and_other_at_ices","text":"","title":"The atload Ice (and other at\u2026 ices)"},{"location":"atload-and-other-at-ices/#introduction","text":"There are four code-receiving ices: atclone , atpull , atinit , atload . Their role is to receive a portion of Zsh code and execute it in certain moments of the plugin life-cycle . The atclone executes it: after cloning the associated plugin or snippet to the disk. The atpull is similar, but works: after updating the associated plugin or snippet. Next, atinit works similar, but is being activated: before loading of the associated plugin or snippet. Last, atload is being activated: after loading of the associated plugin or snippet. For convenience, you can use each of the ices multiple times in single zplugin ice \u2026 invocation \u2013 all the passed commands will be executed in the given order. The atpull ice recognizes a special value: %atclone (so the code looks i.e.: atpull'%atclone' ). It causes the contents of the atclone ice to be copied into the contents of the atpull ice. This is handy when the same tasks have to be performed on clone and on update of plugin or snippet, like e.g.: in the Direnv example .","title":"Introduction"},{"location":"atload-and-other-at-ices/#exclamation_mark-preceded_atload","text":"The wrap-track ice allows to track and unload plugins that defer their initialization into a function run later after sourcing the plugin's script \u2013 when the function is called, the plugin is then being fully initialized. However, if the function is being called from the atload ice, then there is a simpler method than the wrap-track ice \u2013 an exclamation mark -preceded atload contents. The exclamation mark causes the effects of the execution of the code passed to atload ice to be recorded.","title":"Exclamation mark-preceded atload"},{"location":"atload-and-other-at-ices/#example","text":"For example, in the following invocation: zplugin ice id-as'test' atload'!PATH+=:~/share' zplugin load zdharma/null the $PATH is being changed within atload ice. Zplugin's tracking records $PATH changes and withdraws them on plugin unload, and also shows information loading: $ zplg report test Report for test plugin ---------------------- Source (reporting enabled) PATH elements added: /home/sg/share As it can be seen, the atload code is being correctly tracked and can be unloaded & viewed. Below is the result of using the unload subcommand to unload the test plugin: $ zplugin unload test --- Unloading plugin: test --- Removing PATH element /home/sg/share Unregistering plugin test Plugin report saved to $LASTREPORT","title":"Example"},{"location":"atload-and-other-at-ices/#practical_example","text":"The same example as in the Tracking precmd-based Plugins article, but using the exclamation mark -preceded atload instead of wrap-track : # Load when MYPROMPT == 4 zplugin ice load'![[ $MYPROMPT = 4 ]]' unload'![[ $MYPROMPT != 4 ]]' \\ atload'!source ~/.p10k.zsh; _p9k_precmd' zplugin load romkatv/powerlevel10k","title":"Practical example"},{"location":"atload-and-other-at-ices/#summary","text":"The creation of the four additional Zle-widgets will be recorded (see the article on wrap-track for more information) \u2013 the effect will be exactly the same as with the wrap-track ice. The widgets will be properly deleted/restored on the plugin unload with MYPROMPT=3 (for example) and the shell state will be clean, ready to load a new prompt.","title":"Summary"},{"location":"crasis/","text":"Crasis \u2013 semigraphical interface to Zplugin # Zsh exposes its parser via (z) substitution flag. Parsing .zshrc is totally possible. This way Crasis lets you edit your Zplugin commands located in .zshrc . All in pure Zshell code. No more commenting-out a line with a text editor to disable plugin, cluttering .zshrc , now you can just press a button . Crasis uses pure-Zshell ZUI library to create ncurses interface. Installation & Basic Use # Install Zplugin and add following commands to .zshrc : zplugin light zdharma/zui zplugin light zdharma/zplugin-crasis To use, invoke crasis [optional zshrc path] or press Ctrl-o-k . Global variables CRASIS_THEME and CRASIS_LAYOUT can be used to override configuration file crasis.conf (located in plugin's tree), i.e.: CRASIS_THEME=\"zdharma-256\" CRASIS_LAYOUT=\"contract\" crasis 256 -color themes require Zsh 5.3 or later. Key Bindings # Key(s) Description < , > or { , } Horizontal scroll (i.e. left or right) Ctrl-L Redraw of whole display Ctrl-U Half page up Ctrl-D Half page down Ctrl-P Previous line, centered Ctrl-N Next line, centered [ , ] Jump to next and previous section (e.g. next plugin or snippet) g , G Jump to beginning and end of whole interface / Show incremental search F1 Jump to result (in incremental search) and back Esc Exit incremental search, clearing query Ctrl-W Delete whole word (in incremental search) Ctrl-K Delete whole line (in incremental search) Up and down Resize text field when editing it (e.g. to make the text fit in) Screenshots # Code Documentation # Crasis is a ZUI application. ZUI is a pure-Zshell library where user generates simple text with hyperlinks, which is then turned into active document with buttons. Check out Crasis code documentation: Asciidoc , PDF .","title":"Crasis"},{"location":"crasis/#crasis_semigraphical_interface_to_zplugin","text":"Zsh exposes its parser via (z) substitution flag. Parsing .zshrc is totally possible. This way Crasis lets you edit your Zplugin commands located in .zshrc . All in pure Zshell code. No more commenting-out a line with a text editor to disable plugin, cluttering .zshrc , now you can just press a button . Crasis uses pure-Zshell ZUI library to create ncurses interface.","title":"Crasis \u2013 semigraphical interface to Zplugin"},{"location":"crasis/#installation_basic_use","text":"Install Zplugin and add following commands to .zshrc : zplugin light zdharma/zui zplugin light zdharma/zplugin-crasis To use, invoke crasis [optional zshrc path] or press Ctrl-o-k . Global variables CRASIS_THEME and CRASIS_LAYOUT can be used to override configuration file crasis.conf (located in plugin's tree), i.e.: CRASIS_THEME=\"zdharma-256\" CRASIS_LAYOUT=\"contract\" crasis 256 -color themes require Zsh 5.3 or later.","title":"Installation &amp; Basic Use"},{"location":"crasis/#key_bindings","text":"Key(s) Description < , > or { , } Horizontal scroll (i.e. left or right) Ctrl-L Redraw of whole display Ctrl-U Half page up Ctrl-D Half page down Ctrl-P Previous line, centered Ctrl-N Next line, centered [ , ] Jump to next and previous section (e.g. next plugin or snippet) g , G Jump to beginning and end of whole interface / Show incremental search F1 Jump to result (in incremental search) and back Esc Exit incremental search, clearing query Ctrl-W Delete whole word (in incremental search) Ctrl-K Delete whole line (in incremental search) Up and down Resize text field when editing it (e.g. to make the text fit in)","title":"Key Bindings"},{"location":"crasis/#screenshots","text":"","title":"Screenshots"},{"location":"crasis/#code_documentation","text":"Crasis is a ZUI application. ZUI is a pure-Zshell library where user generates simple text with hyperlinks, which is then turned into active document with buttons. Check out Crasis code documentation: Asciidoc , PDF .","title":"Code Documentation"},{"location":"declare-zsh/","text":"declare-zsh # declare-zsh is a parser for zplugin commands in .zshrc . It allows to perform the following actions on .zshrc from the command-line : enable and disable selected plugins and snippets, add plugins and snippets, delete plugins and snippets. In other words, by issuing a declzsh command the user deploys a task of: Reading and parsing of the ~/.zshrc . Making changes (like removal of a plugin, i.e. of zplugin load {removed-plugin} command together with the possible associated zplugin ice \u2026 command) and then\u2026 Writing the result back to the zshrc (by default, the result is stored to ~/.zshrc_gen file for safety, but the author wants to emhasize very strongly, that breaking something within the parsed zshrc is nearly impossible and the tool can be safely used with option -o ~/.zshrc which points declzsh to the original zshrc as the destination, output file). Examples & Screenshots # Example disabling of a plugin via the toggle option -TT \u2013 this works because the commands preceded by : are ignored by the shell: Example addition of a plugin via the option -AA \u2013 in order to also set up ice modifiers enclose them in a preceding square-bracket block, i.e. declzsh -AA '[ wait\"1\" lucid ] zdharma/null' : Example deletion of a plugin via the purge option -PP \u2013 the argument is treated as pattern, pass * to delete all plugins and snippets!: Usage # Multiple actions, i.e. multiple options like -AA , -PP , -DD , etc. are possible in a single declzsh run.","title":"declare-zsh"},{"location":"declare-zsh/#declare-zsh","text":"declare-zsh is a parser for zplugin commands in .zshrc . It allows to perform the following actions on .zshrc from the command-line : enable and disable selected plugins and snippets, add plugins and snippets, delete plugins and snippets. In other words, by issuing a declzsh command the user deploys a task of: Reading and parsing of the ~/.zshrc . Making changes (like removal of a plugin, i.e. of zplugin load {removed-plugin} command together with the possible associated zplugin ice \u2026 command) and then\u2026 Writing the result back to the zshrc (by default, the result is stored to ~/.zshrc_gen file for safety, but the author wants to emhasize very strongly, that breaking something within the parsed zshrc is nearly impossible and the tool can be safely used with option -o ~/.zshrc which points declzsh to the original zshrc as the destination, output file).","title":"declare-zsh"},{"location":"declare-zsh/#examples_screenshots","text":"Example disabling of a plugin via the toggle option -TT \u2013 this works because the commands preceded by : are ignored by the shell: Example addition of a plugin via the option -AA \u2013 in order to also set up ice modifiers enclose them in a preceding square-bracket block, i.e. declzsh -AA '[ wait\"1\" lucid ] zdharma/null' : Example deletion of a plugin via the purge option -PP \u2013 the argument is treated as pattern, pass * to delete all plugins and snippets!:","title":"Examples &amp; Screenshots"},{"location":"declare-zsh/#usage","text":"Multiple actions, i.e. multiple options like -AA , -PP , -DD , etc. are possible in a single declzsh run.","title":"Usage"},{"location":"id-as/","text":"Nickname a plugin or snippet # Zplugin supports loading a plugin or snippet with a nickname. Set the nickname through the id-as ice-mod. For example, one could try to load docker/compose from GitHub binary releases: zplugin ice as\"program\" from\"gh-r\" mv\"docker-c* -> docker-compose\" zplugin light \"docker/compose\" This registers plugin under the ID docker/compose . Now suppose the user would want to also load a completion from the project's GitHub repository (not the binary release catalog) which is also available under the GitHub url-path \u2026/docker/compose . The two IDs, both being \"docker/compose\", will collide. The solution to this problem \u2013 the id-as (to be read as: identify-as ) ice to which this document is devoted: by using the id-as ice the user can resolve the conflict by loading the completion under a kind of a nickname , for example under \" dc-complete \", by issuing the following commands: zplugin ice as\"completion\" id-as\"dc-complete\" zplugin load docker/compose The plugin (of the type completion ) is now seen under ID dc-complete : ~ zplugin list | grep -i dc-complete dc-complete Issuing zplugin report dc-complete also works, so as other Zplugin commands: ~ zplugin report dc-complete Plugin report for dc-complete ------------------------------- Completions: _docker-compose [enabled] This can be also used to nickname snippets. For example, you can use this to create handy IDs in place of long urls: zplugin ice as\"program\" id-as\"git-unique\" zplugin snippet https://github.com/Osse/git-scripts/blob/master/git-unique The commands zplugin update git-unique , zplugin delete git-unique and other will work normally and e.g. zplugin times will show the nickname -ID git-unique instead of the long URL.","title":"Nickname a Plugin or Snippet"},{"location":"id-as/#nickname_a_plugin_or_snippet","text":"Zplugin supports loading a plugin or snippet with a nickname. Set the nickname through the id-as ice-mod. For example, one could try to load docker/compose from GitHub binary releases: zplugin ice as\"program\" from\"gh-r\" mv\"docker-c* -> docker-compose\" zplugin light \"docker/compose\" This registers plugin under the ID docker/compose . Now suppose the user would want to also load a completion from the project's GitHub repository (not the binary release catalog) which is also available under the GitHub url-path \u2026/docker/compose . The two IDs, both being \"docker/compose\", will collide. The solution to this problem \u2013 the id-as (to be read as: identify-as ) ice to which this document is devoted: by using the id-as ice the user can resolve the conflict by loading the completion under a kind of a nickname , for example under \" dc-complete \", by issuing the following commands: zplugin ice as\"completion\" id-as\"dc-complete\" zplugin load docker/compose The plugin (of the type completion ) is now seen under ID dc-complete : ~ zplugin list | grep -i dc-complete dc-complete Issuing zplugin report dc-complete also works, so as other Zplugin commands: ~ zplugin report dc-complete Plugin report for dc-complete ------------------------------- Completions: _docker-compose [enabled] This can be also used to nickname snippets. For example, you can use this to create handy IDs in place of long urls: zplugin ice as\"program\" id-as\"git-unique\" zplugin snippet https://github.com/Osse/git-scripts/blob/master/git-unique The commands zplugin update git-unique , zplugin delete git-unique and other will work normally and e.g. zplugin times will show the nickname -ID git-unique instead of the long URL.","title":"Nickname a plugin or snippet"},{"location":"preinstalling-plugins/","text":"Preinstalling Plugins # If you create a Docker image that uses Zplugin, or want to install Turbo-loaded plugins before the shell starts interactively, you can invoke the zplugin-scheduler function in such a way, that it: installs plugins without waiting for the prompt (i.e. it's script friendly), installs all plugins instantly, without respecting the wait'' argument. To accomplish this, use burst argument and call -zplg-scheduler function. Example Dockerfile entry: RUN zsh -i -c -- '-zplg-scheduler burst || true' An example Dockerfile can be found here .","title":"Preinstalling Plugins"},{"location":"preinstalling-plugins/#preinstalling_plugins","text":"If you create a Docker image that uses Zplugin, or want to install Turbo-loaded plugins before the shell starts interactively, you can invoke the zplugin-scheduler function in such a way, that it: installs plugins without waiting for the prompt (i.e. it's script friendly), installs all plugins instantly, without respecting the wait'' argument. To accomplish this, use burst argument and call -zplg-scheduler function. Example Dockerfile entry: RUN zsh -i -c -- '-zplg-scheduler burst || true' An example Dockerfile can be found here .","title":"Preinstalling Plugins"},{"location":"wrap-track/","text":"The wrap-track Ice # The wrap-track ice-mod allows to extend the tracking (i.e. gathering of report and unload data) of a plugin beyond the moment of sourcing it's main file(s). It works by wrapping the given functions with a tracking-enabling and disabling snippet of code. This is useful especially with prompts, as they very often do their initialization in the first call to their precmd hook function. For example, romkatv/powerlevel10k works this way. The ice takes a list of function names, with the elements separated by ; : zplugin ice wrap-track\"func1;func2;\u2026\" \u2026 \u2026 Example # Therefore, to e.g. load and unload the example powerlevel10k prompt in the fashion of Multiple prompts article, the precmd function of the plugin \u2013 called _p9k_precmd (to get the name of the function do echo $precmd_functions after loading a theme) \u2013 should be passed to wrap-track'' ice, like so: # Load when MYPROMPT == 4 zplugin ice load'![[ $MYPROMPT = 4 ]]' unload'![[ $MYPROMPT != 4 ]]' \\ atload'source ~/.p10k.zsh; _p9k_precmd' wrap-track'_p9k_precmd' zplugin load romkatv/powerlevel10k This way the actions done during the first call to _p9k_precmd() will be normally recorded, which can be viewed in the report of the romkatv/powerlevel10k theme: ~ zplg report romkatv/powerlevel10k: Report for romkatv/powerlevel10k plugin --------------------------------------- Source powerlevel10k.zsh-theme (reporting enabled) Autoload is-at-least with options -U -z (\u2026) Note: === Starting to track function: _p9k_precmd === Zle -N p9k-orig-zle-line-finish _zsh_highlight_widget_zle-line-finish Note: a new widget created via zle -N: p9k-orig-zle-line-finish Zle -N -- zle-line-finish _p9k_wrapper__p9k_zle_line_finish Autoload vcs_info with options -U -z Zstyle :vcs_info:* check-for-changes true (\u2026) Zstyle :vcs_info:* get-revision false Autoload add-zsh-hook with options -U -z Zle -F 22 _gitstatus_process_response_POWERLEVEL9K Autoload _gitstatus_cleanup_15877_0_16212 Zle -N -- zle-line-pre-redraw _p9k_wrapper__p9k_zle_line_pre_redraw Note: a new widget created via zle -N: zle-line-pre-redraw Zle -N -- zle-keymap-select _p9k_wrapper__p9k_zle_keymap_select Note: === Ended tracking function: _p9k_precmd === Functions created: +vi-git-aheadbehind +vi-git-remotebranch (\u2026) Summary # As it can be seen, creation of four additional Zle-widgets has been recorded (the Zle -N \u2026 lines). They will be properly deleted/restored on the plugin unload with MYPROMPT=3 (for example) and the shell state will be clean, ready to load a new prompt.","title":"Tracking precmd-based Plugins"},{"location":"wrap-track/#the_wrap-track_ice","text":"The wrap-track ice-mod allows to extend the tracking (i.e. gathering of report and unload data) of a plugin beyond the moment of sourcing it's main file(s). It works by wrapping the given functions with a tracking-enabling and disabling snippet of code. This is useful especially with prompts, as they very often do their initialization in the first call to their precmd hook function. For example, romkatv/powerlevel10k works this way. The ice takes a list of function names, with the elements separated by ; : zplugin ice wrap-track\"func1;func2;\u2026\" \u2026 \u2026","title":"The wrap-track Ice"},{"location":"wrap-track/#example","text":"Therefore, to e.g. load and unload the example powerlevel10k prompt in the fashion of Multiple prompts article, the precmd function of the plugin \u2013 called _p9k_precmd (to get the name of the function do echo $precmd_functions after loading a theme) \u2013 should be passed to wrap-track'' ice, like so: # Load when MYPROMPT == 4 zplugin ice load'![[ $MYPROMPT = 4 ]]' unload'![[ $MYPROMPT != 4 ]]' \\ atload'source ~/.p10k.zsh; _p9k_precmd' wrap-track'_p9k_precmd' zplugin load romkatv/powerlevel10k This way the actions done during the first call to _p9k_precmd() will be normally recorded, which can be viewed in the report of the romkatv/powerlevel10k theme: ~ zplg report romkatv/powerlevel10k: Report for romkatv/powerlevel10k plugin --------------------------------------- Source powerlevel10k.zsh-theme (reporting enabled) Autoload is-at-least with options -U -z (\u2026) Note: === Starting to track function: _p9k_precmd === Zle -N p9k-orig-zle-line-finish _zsh_highlight_widget_zle-line-finish Note: a new widget created via zle -N: p9k-orig-zle-line-finish Zle -N -- zle-line-finish _p9k_wrapper__p9k_zle_line_finish Autoload vcs_info with options -U -z Zstyle :vcs_info:* check-for-changes true (\u2026) Zstyle :vcs_info:* get-revision false Autoload add-zsh-hook with options -U -z Zle -F 22 _gitstatus_process_response_POWERLEVEL9K Autoload _gitstatus_cleanup_15877_0_16212 Zle -N -- zle-line-pre-redraw _p9k_wrapper__p9k_zle_line_pre_redraw Note: a new widget created via zle -N: zle-line-pre-redraw Zle -N -- zle-keymap-select _p9k_wrapper__p9k_zle_keymap_select Note: === Ended tracking function: _p9k_precmd === Functions created: +vi-git-aheadbehind +vi-git-remotebranch (\u2026)","title":"Example"},{"location":"wrap-track/#summary","text":"As it can be seen, creation of four additional Zle-widgets has been recorded (the Zle -N \u2026 lines). They will be properly deleted/restored on the plugin unload with MYPROMPT=3 (for example) and the shell state will be clean, ready to load a new prompt.","title":"Summary"},{"location":"z-p-man/","text":"z-p-man # A Zplugin extension that automatically generates: man pages for all plugins and snippets (out of plugin README.md files by using ronn converter), code-documentation manpages (by using zshelldoc project). Man extension is being activated at clone of a plugin and also at update of it and it then generates the manpages. To view them there's a zman command: # View README.md manpage in the terminal zman z-p-man # View the code documentation (via the full plugin name, as demonstrated) zman -c zdharma/z-p-man Screenshots # Main manual (of the project): Code documentation for the plugin.zsh file (of the project): Installation # Simply load as a plugin. This will install the extension within Zplugin: zplugin light zdharma/z-p-man","title":"z-p-man"},{"location":"z-p-man/#z-p-man","text":"A Zplugin extension that automatically generates: man pages for all plugins and snippets (out of plugin README.md files by using ronn converter), code-documentation manpages (by using zshelldoc project). Man extension is being activated at clone of a plugin and also at update of it and it then generates the manpages. To view them there's a zman command: # View README.md manpage in the terminal zman z-p-man # View the code documentation (via the full plugin name, as demonstrated) zman -c zdharma/z-p-man","title":"z-p-man"},{"location":"z-p-man/#screenshots","text":"Main manual (of the project): Code documentation for the plugin.zsh file (of the project):","title":"Screenshots"},{"location":"z-p-man/#installation","text":"Simply load as a plugin. This will install the extension within Zplugin: zplugin light zdharma/z-p-man","title":"Installation"},{"location":"z-p-submods/","text":"Introduction # A z-plugin (i.e. a plugin for the Zplugin \u2013 more information ) that allows Zplugin to clone additional submodules when installing a plugin or snippet. The submodules are then automatically updated on the zplugin update \u2026 command. This z-plugin adds submods'' ice to Zplugin which has the following syntax: submods'{user}/{plugin} -> {output directory}; \u2026' An example command utilizing the z-plugin and its ice: # Load zsh-autosuggestions plugin via Prezto module: autosuggestions zplugin ice svn submods'zsh-users/zsh-autosuggestions -> external' zplugin snippet PZT::modules/autosuggestions Installation # Simply load as a plugin. The following command will install the z-plugin within Zplugin: zplugin light zdharma/z-p-submods After executing this command you can then use the submods'' ice. The command should be placed in ~/.zshrc .","title":"z-p-submods"},{"location":"z-p-submods/#introduction","text":"A z-plugin (i.e. a plugin for the Zplugin \u2013 more information ) that allows Zplugin to clone additional submodules when installing a plugin or snippet. The submodules are then automatically updated on the zplugin update \u2026 command. This z-plugin adds submods'' ice to Zplugin which has the following syntax: submods'{user}/{plugin} -> {output directory}; \u2026' An example command utilizing the z-plugin and its ice: # Load zsh-autosuggestions plugin via Prezto module: autosuggestions zplugin ice svn submods'zsh-users/zsh-autosuggestions -> external' zplugin snippet PZT::modules/autosuggestions","title":"Introduction"},{"location":"z-p-submods/#installation","text":"Simply load as a plugin. The following command will install the z-plugin within Zplugin: zplugin light zdharma/z-p-submods After executing this command you can then use the submods'' ice. The command should be placed in ~/.zshrc .","title":"Installation"},{"location":"z-p-test/","text":"z-p-test # Zplugin extension that runs tests (via make test , for example) \u2013 if it finds any of them \u2013 after installing and updating a plugin or snippet. Simply load it as a plugin to make it active: zplugin light zdharma/z-p-test Example activation in the default quiet mode: Example activation in non-quiet mode: Installation # Simply load as a plugin. This will install the extension within Zplugin: zplugin light zdharma/z-p-test","title":"z-p-test"},{"location":"z-p-test/#z-p-test","text":"Zplugin extension that runs tests (via make test , for example) \u2013 if it finds any of them \u2013 after installing and updating a plugin or snippet. Simply load it as a plugin to make it active: zplugin light zdharma/z-p-test Example activation in the default quiet mode: Example activation in non-quiet mode:","title":"z-p-test"},{"location":"z-p-test/#installation","text":"Simply load as a plugin. This will install the extension within Zplugin: zplugin light zdharma/z-p-test","title":"Installation"},{"location":"zplugin-autoload.zsh/","text":"zplugin-autoload.zsh(1) # NAME # zplugin-autoload.zsh - a shell script SYNOPSIS # Documentation automatically generated with `zshelldoc' FUNCTIONS # -zplg-any-to-uspl2 -zplg-at-eval -zplg-build-module -zplg-cd -zplg-cdisable -zplg-cenable -zplg-changes -zplg-check-comp-consistency -zplg-check-which-completions-are-enabled -zplg-check-which-completions-are-installed -zplg-clear-completions -zplg-clear-report-for -zplg-compiled -zplg-compile-uncompile-all -zplg-compinit -zplg-compute-ice -zplg-confirm -zplg-create -zplg-delete -zplg-diff-env-compute -zplg-diff-functions-compute -zplg-diff-options-compute -zplg-diff-parameter-compute -zplg-edit -zplg-exists-message -zplg-find-completions-of-plugin -zplg-format-env -zplg-format-functions -zplg-format-options -zplg-format-parameter -zplg-get-completion-owner -zplg-get-completion-owner-uspl2col -zplg-get-path -zplg-glance -zplg-help -zplg-list-bindkeys -zplg-list-compdef-replay -zplg-ls -zplg-module -zplg-prepare-readlink -zplg-recall -zplg-recently -zplg-restore-extendedglob -zplg-save-set-extendedglob -zplg-search-completions -zplg-self-update -zplg-show-all-reports -zplg-show-completions -zplg-show-debug-report -zplg-show-registered-plugins -zplg-show-report -zplg-show-times -zplg-show-zstatus -zplg-stress -zplg-uncompile-plugin -zplg-uninstall-completions -zplg-unload -zplg-update-or-status -zplg-update-or-status-all -zplg-update-or-status-snippet AUTOLOAD compinit DETAILS # Script Body # Has 5 line(s). No functions are called (may set up e.g. a hook, a Zle widget bound to a key, etc.). Uses feature(s): source -zplg-any-to-uspl2 # Converts given plugin-spec to format that's used in keys for hash tables. So basically, creates string \"user/plugin\" (this format is called: uspl2). $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - (optional) plugin (only when $1 - i.e. user - given) Has 2 line(s). Calls functions: -zplg-any-to-uspl2 `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: -zplg-clear-report-for -zplg-exists-message -zplg-at-eval # Has 1 line(s). Doesn't call other functions. Uses feature(s): eval Called by: -zplg-update-or-status -zplg-build-module # Performs ./configure && make on the module and displays information how to load the module in .zshrc. Has 27 line(s). Calls functions: -zplg-build-module `-- -zplg-module Uses feature(s): trap Called by: -zplg-module -zplg-cd # Jumps to plugin's directory (in Zplugin's home directory). User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 13 line(s). Calls functions: -zplg-cd `-- -zplg-get-path |-- zplugin-side.zsh/-zplg-exists-physically |-- zplugin-side.zsh/-zplg-shands-exp |-- zplugin-side.zsh/-zplg-two-paths `-- zplugin.zsh/-zplg-any-to-user-plugin Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). -zplg-cdisable # Enables given installed completion. User-action entry point. $1 - e.g. \"_mkdir\" or \"mkdir\" Has 30 line(s). Calls functions: -zplg-cdisable |-- -zplg-check-comp-consistency |-- -zplg-get-completion-owner-uspl2col | |-- -zplg-get-completion-owner | `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 `-- -zplg-prepare-readlink Called by: zplugin.zsh/zplugin -zplg-cenable # Disables given installed completion. User-action entry point. $1 - e.g. \"_mkdir\" or \"mkdir\" Has 31 line(s). Calls functions: -zplg-cenable |-- -zplg-check-comp-consistency |-- -zplg-get-completion-owner-uspl2col | |-- -zplg-get-completion-owner | `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 `-- -zplg-prepare-readlink Called by: zplugin.zsh/zplugin -zplg-changes # Shows `git log` of given plugin. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 9 line(s). Calls functions: -zplg-changes |-- zplugin-side.zsh/-zplg-exists-physically-message `-- zplugin.zsh/-zplg-any-to-user-plugin Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). -zplg-check-comp-consistency # Zplugin creates symlink for each installed completion. This function checks whether given completion (i.e. file like \"_mkdir\") is indeed a symlink. Backup file is a completion that is disabled - has the leading \"_\" removed. $1 - path to completion within plugin's directory $2 - path to backup file within plugin's directory Has 11 line(s). Doesn't call other functions. Called by: -zplg-cdisable -zplg-cenable -zplg-check-which-completions-are-enabled # For each argument that each should be a path to completion within a plugin's dir, it checks whether that completion is disabled - returns 0 or 1 on corresponding positions in reply. Uninstalled completions will be reported as \"0\" - i.e. disabled $1, ... - path to completion within plugin's directory Has 11 line(s). Doesn't call other functions. Called by: -zplg-show-report -zplg-check-which-completions-are-installed # For each argument that each should be a path to completion within a plugin's dir, it checks whether that completion is installed - returns 0 or 1 on corresponding positions in reply. $1, ... - path to completion within plugin's directory Has 12 line(s). Doesn't call other functions. Called by: -zplg-show-report -zplg-clear-completions # Delete stray and improper completions. Completions live even when plugin isn't loaded - if they are installed and enabled. User-action entry point. Has 37 line(s). Calls functions: -zplg-clear-completions |-- -zplg-get-completion-owner |-- -zplg-prepare-readlink `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 Called by: zplugin.zsh/zplugin -zplg-clear-report-for # Clears all report data for given user/plugin. This is done by resetting all related global ZPLG_* hashes. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - (optional) plugin (only when $1 - i.e. user - given) Has 23 line(s). Calls functions: -zplg-clear-report-for `-- -zplg-any-to-uspl2 `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: -zplg-unload zplugin.zsh/-zplg-clear-debug-report -zplg-compiled # Displays list of plugins that are compiled. User-action entry point. Has 26 line(s). Calls functions: -zplg-compiled |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: zplugin.zsh/zplugin -zplg-compile-uncompile-all # Compiles or uncompiles all existing (on disk) plugins. User-action entry point. Has 23 line(s). Calls functions: -zplg-compile-uncompile-all |-- -zplg-uncompile-plugin | |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 | `-- zplugin.zsh/-zplg-any-to-user-plugin |-- zplugin-install.zsh/-zplg-compile-plugin |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: zplugin.zsh/zplugin -zplg-compinit # User-exposed `compinit' frontend which first ensures that all completions managed by Zplugin are forgotten by Zshell. After that it runs normal `compinit', which should more easily detect Zplugin's completions. No arguments. Has 23 line(s). Calls functions: -zplg-compinit |-- compinit `-- zplugin-install.zsh/-zplg-forget-completion Uses feature(s): autoload , unfunction Called by: zplugin.zsh/zplugin -zplg-compute-ice # Computes ZPLG_ICE array (default, it can be specified via $3) from a) input ZPLG_ICE, b) static ice, c) saved ice, taking priorities into account. Also returns path to snippet directory and optional name of snippet file (only valid if ZPLG_ICE[svn] is not set). Can also pack resulting ices into ZPLG_SICE (see $2). $1 - URL (also plugin-spec) $2 - \"pack\" or \"nopack\" or \"pack-nf\" - packing means ZPLG_ICE wins with static ice; \"pack-nf\" means that disk-ices will be ignored (no-file?) $3 - name of output associative array, \"ZPLG_ICE\" is the default $4 - name of output string parameter, to hold path to directory (\"local_dir\") $5 - name of output string parameter, to hold filename (\"filename\") Has 98 line(s). Calls functions: -zplg-compute-ice |-- zplugin-side.zsh/-zplg-exists-physically-message |-- zplugin-side.zsh/-zplg-shands-exp |-- zplugin-side.zsh/-zplg-two-paths |-- zplugin.zsh/-zplg-any-to-user-plugin `-- zplugin.zsh/-zplg-pack-ice Uses feature(s): wait Called by: -zplg-recall -zplg-update-or-status-snippet -zplg-update-or-status -zplg-confirm # Prints given question, waits for \"y\" key, evals given expression if \"y\" obtained $1 - question $2 - expression Has 5 line(s). Doesn't call other functions. Uses feature(s): eval , read Called by: -zplg-delete -zplg-create # Creates a plugin, also on Github (if not \"_local/name\" plugin). User-action entry point. $1 - (optional) plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - (optional) plugin (only when $1 - i.e. user - given) Has 66 line(s). Calls functions: -zplg-create |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 |-- zplugin-side.zsh/-zplg-exists-physically `-- zplugin.zsh/-zplg-any-to-user-plugin Uses feature(s): vared Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). -zplg-delete # Deletes plugin's or snippet's directory (in Zplugin's home directory). User-action entry point. $1 - snippet URL or plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 54 line(s). Calls functions: -zplg-delete |-- -zplg-confirm |-- zplugin-side.zsh/-zplg-exists-physically-message |-- zplugin-side.zsh/-zplg-shands-exp |-- zplugin-side.zsh/-zplg-two-paths `-- zplugin.zsh/-zplg-any-to-user-plugin Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). -zplg-diff-env-compute # Computes ZPLG_PATH, ZPLG_FPATH that hold (f)path components added by plugin. Uses data gathered earlier by -zplg-diff-env(). $1 - user/plugin Has 30 line(s). Doesn't call other functions. Called by: -zplg-show-report -zplg-unload -zplg-diff-functions-compute # Computes FUNCTIONS that holds new functions added by plugin. Uses data gathered earlier by -zplg-diff-functions(). $1 - user/plugin Has 19 line(s). Doesn't call other functions. Called by: -zplg-show-report -zplg-unload -zplg-diff-options-compute # Computes OPTIONS that holds options changed by plugin. Uses data gathered earlier by -zplg-diff-options(). $1 - user/plugin Has 17 line(s). Doesn't call other functions. Called by: -zplg-show-report -zplg-unload -zplg-diff-parameter-compute # Computes ZPLG_PARAMETERS_PRE, ZPLG_PARAMETERS_POST that hold parameters created or changed (their type) by plugin. Uses data gathered earlier by -zplg-diff-parameter(). $1 - user/plugin Has 28 line(s). Doesn't call other functions. Called by: -zplg-show-report -zplg-unload -zplg-edit # Runs $EDITOR on source of given plugin. If the variable is not set then defaults to `vim'. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 13 line(s). Calls functions: -zplg-edit |-- zplugin-side.zsh/-zplg-exists-physically-message |-- zplugin-side.zsh/-zplg-first `-- zplugin.zsh/-zplg-any-to-user-plugin Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). -zplg-exists-message # Checks if plugin is loaded. Testable. Also outputs error message if plugin is not loaded. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - (optional) plugin (only when $1 - i.e. user - given) Has 7 line(s). Calls functions: -zplg-exists-message |-- -zplg-any-to-uspl2 | `-- zplugin.zsh/-zplg-any-to-user-plugin `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 Called by: -zplg-show-report -zplg-unload -zplg-find-completions-of-plugin # Searches for completions owned by given plugin. Returns them in `reply' array. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 6 line(s). Calls functions: -zplg-find-completions-of-plugin `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: -zplg-show-report -zplg-format-env # Creates one-column text about FPATH or PATH elements added when given plugin was loaded. $1 - user/plugin (i.e. uspl2 format of plugin-spec) $2 - if 1, then examine PATH, if 2, then examine FPATH Has 16 line(s). Doesn't call other functions. Called by: -zplg-show-report -zplg-format-functions # Creates a one or two columns text with functions created by given plugin. $1 - user/plugin (i.e. uspl2 format of plugin-spec) Has 36 line(s). Doesn't call other functions. Called by: -zplg-show-report -zplg-format-options # Creates one-column text about options that changed when plugin \"$1\" was loaded. $1 - user/plugin (i.e. uspl2 format of plugin-spec) Has 21 line(s). Calls functions: -zplg-format-options |-- -zplg-restore-extendedglob `-- -zplg-save-set-extendedglob Called by: -zplg-show-report -zplg-format-parameter # Creates one column text that lists global parameters that changed when the given plugin was loaded. $1 - user/plugin (i.e. uspl2 format of plugin-spec) Has 34 line(s). Doesn't call other functions. Called by: -zplg-show-report -zplg-get-completion-owner # Returns \"user---plugin\" string (uspl1 format) of plugin that owns given completion. Both :A and readlink will be used, then readlink's output if results differ. Readlink might not be available. :A will read the link \"twice\" and give the final repository directory, possibly without username in the uspl format; readlink will read the link \"once\" $1 - absolute path to completion file (in COMPLETIONS_DIR) $2 - readlink command (\":\" or \"readlink\") Has 22 line(s). Doesn't call other functions. Called by: -zplg-clear-completions -zplg-get-completion-owner-uspl2col -zplg-show-completions -zplg-get-completion-owner-uspl2col # For shortening of code - returns colorized plugin name that owns given completion. $1 - absolute path to completion file (in COMPLETIONS_DIR) $2 - readlink command (\":\" or \"readlink\") Has 2 line(s). Calls functions: -zplg-get-completion-owner-uspl2col |-- -zplg-get-completion-owner `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 Called by: -zplg-cdisable -zplg-cenable -zplg-get-path # Returns path of given ID-string, which may be a plugin-spec (like \"user/plugin\" or \"user\" \"plugin\"), an absolute path (\"%\" \"/home/...\" and also \"%SNIPPETS/...\" etc.), or a plugin nickname (i.e. id-as'' ice-mod), or a snippet nickname. Has 35 line(s). Calls functions: -zplg-get-path |-- zplugin-side.zsh/-zplg-exists-physically |-- zplugin-side.zsh/-zplg-shands-exp |-- zplugin-side.zsh/-zplg-two-paths `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: -zplg-cd -zplg-uninstall-completions -zplg-glance # Shows colorized source code of plugin. Is able to use pygmentize, highlight, GNU source-highlight. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 39 line(s). Calls functions: -zplg-glance |-- zplugin-side.zsh/-zplg-exists-physically-message |-- zplugin-side.zsh/-zplg-first `-- zplugin.zsh/-zplg-any-to-user-plugin Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). -zplg-help # Shows usage information. User-action entry point. Has 68 line(s). Doesn't call other functions. Called by: zplugin.zsh/zplugin -zplg-list-bindkeys # Has 42 line(s). Calls functions: -zplg-list-bindkeys `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 Called by: zplugin.zsh/zplugin -zplg-list-compdef-replay # Shows recorded compdefs (called by plugins loaded earlier). Plugins often call `compdef' hoping for `compinit' being already ran. Zplugin solves this by recording compdefs. User-action entry point. Has 5 line(s). Doesn't call other functions. Called by: zplugin.zsh/zplugin -zplg-ls # Has 19 line(s). Doesn't call other functions. Called by: zplugin.zsh/zplugin -zplg-module # Function that has sub-commands passed as long-options (with two dashes, --). It's an attempt to plugin only this one function into `zplugin' function defined in zplugin.zsh, to not make this file longer than it's needed. Has 24 line(s). Calls functions: -zplg-module `-- -zplg-build-module Called by: -zplg-build-module zplugin.zsh/zplugin -zplg-prepare-readlink # Prepares readlink command, used for establishing completion's owner. $REPLY = \":\" or \"readlink\" Has 4 line(s). Doesn't call other functions. Uses feature(s): type Called by: -zplg-cdisable -zplg-cenable -zplg-clear-completions -zplg-show-completions -zplg-recall # Has 37 line(s). Calls functions: -zplg-recall `-- -zplg-compute-ice |-- zplugin-side.zsh/-zplg-exists-physically-message |-- zplugin-side.zsh/-zplg-shands-exp |-- zplugin-side.zsh/-zplg-two-paths |-- zplugin.zsh/-zplg-any-to-user-plugin `-- zplugin.zsh/-zplg-pack-ice Uses feature(s): wait Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). -zplg-recently # Shows plugins that obtained commits in specified past time. User-action entry point. $1 - time spec, e.g. \"1 week\" Has 26 line(s). Calls functions: -zplg-recently `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 Called by: zplugin.zsh/zplugin -zplg-restore-extendedglob # Restores extendedglob-option from state saved earlier. Has 1 line(s). Doesn't call other functions. Called by: -zplg-format-options -zplg-show-registered-plugins -zplg-unload -zplg-save-set-extendedglob # Enables extendedglob-option first saving if it was already enabled, for restoration of this state later. Has 2 line(s). Doesn't call other functions. Called by: -zplg-format-options -zplg-show-registered-plugins -zplg-unload -zplg-search-completions # While -zplg-show-completions() shows what completions are installed, this functions searches through all plugin dirs showing what's available in general (for installation). User-action entry point. Has 43 line(s). Calls functions: -zplg-search-completions `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 Called by: zplugin.zsh/zplugin -zplg-self-update # Updates Zplugin code (does a git pull). User-action entry point. Has 23 line(s). Doesn't call other functions. Uses feature(s): zcompile Called by: zplugin.zsh/zplugin -zplg-show-all-reports # Displays reports of all loaded plugins. User-action entry point. Has 5 line(s). Calls functions: -zplg-show-all-reports `-- -zplg-show-report |-- -zplg-check-which-completions-are-enabled |-- -zplg-check-which-completions-are-installed |-- -zplg-diff-env-compute |-- -zplg-diff-functions-compute |-- -zplg-diff-options-compute |-- -zplg-diff-parameter-compute |-- -zplg-exists-message | |-- -zplg-any-to-uspl2 | | `-- zplugin.zsh/-zplg-any-to-user-plugin | `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 |-- -zplg-find-completions-of-plugin | `-- zplugin.zsh/-zplg-any-to-user-plugin |-- -zplg-format-env |-- -zplg-format-functions |-- -zplg-format-options | |-- -zplg-restore-extendedglob | `-- -zplg-save-set-extendedglob |-- -zplg-format-parameter `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: zplugin.zsh/zplugin -zplg-show-completions # Display installed (enabled and disabled), completions. Detect stray and improper ones. Completions live even when plugin isn't loaded - if they are installed and enabled. User-action entry point. Has 72 line(s). Calls functions: -zplg-show-completions |-- -zplg-get-completion-owner |-- -zplg-prepare-readlink `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 Called by: zplugin.zsh/zplugin -zplg-show-debug-report # Displays dtrace report (data recorded in interactive session). User-action entry point. Has 1 line(s). Calls functions: -zplg-show-debug-report `-- -zplg-show-report |-- -zplg-check-which-completions-are-enabled |-- -zplg-check-which-completions-are-installed |-- -zplg-diff-env-compute |-- -zplg-diff-functions-compute |-- -zplg-diff-options-compute |-- -zplg-diff-parameter-compute |-- -zplg-exists-message | |-- -zplg-any-to-uspl2 | | `-- zplugin.zsh/-zplg-any-to-user-plugin | `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 |-- -zplg-find-completions-of-plugin | `-- zplugin.zsh/-zplg-any-to-user-plugin |-- -zplg-format-env |-- -zplg-format-functions |-- -zplg-format-options | |-- -zplg-restore-extendedglob | `-- -zplg-save-set-extendedglob |-- -zplg-format-parameter `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: zplugin.zsh/zplugin -zplg-show-registered-plugins # Lists loaded plugins (subcommands list, lodaded). User-action entry point. Has 21 line(s). Calls functions: -zplg-show-registered-plugins |-- -zplg-restore-extendedglob |-- -zplg-save-set-extendedglob `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 Called by: zplugin.zsh/zplugin -zplg-show-report # Displays report of the plugin given. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user (+ plugin in $2), plugin) $2 - plugin (only when $1 - i.e. user - given) Has 71 line(s). Calls functions: -zplg-show-report |-- -zplg-check-which-completions-are-enabled |-- -zplg-check-which-completions-are-installed |-- -zplg-diff-env-compute |-- -zplg-diff-functions-compute |-- -zplg-diff-options-compute |-- -zplg-diff-parameter-compute |-- -zplg-exists-message | |-- -zplg-any-to-uspl2 | | `-- zplugin.zsh/-zplg-any-to-user-plugin | `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 |-- -zplg-find-completions-of-plugin | `-- zplugin.zsh/-zplg-any-to-user-plugin |-- -zplg-format-env |-- -zplg-format-functions |-- -zplg-format-options | |-- -zplg-restore-extendedglob | `-- -zplg-save-set-extendedglob |-- -zplg-format-parameter `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: -zplg-show-all-reports -zplg-show-debug-report zplugin.zsh/zplugin -zplg-show-times # Shows loading times of all loaded plugins. User-action entry point. Has 42 line(s). Calls functions: -zplg-show-times `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 Called by: zplugin.zsh/zplugin -zplg-show-zstatus # Shows Zplugin status, i.e. number of loaded plugins, of available completions, etc. User-action entry point. Has 41 line(s). Doesn't call other functions. Called by: zplugin.zsh/zplugin -zplg-stress # Compiles plugin with various options on and off to see how well the code is written. The options are: NO_SHORT_LOOPS, IGNORE_BRACES, IGNORE_CLOSE_BRACES, SH_GLOB, CSH_JUNKIE_QUOTES, NO_MULTI_FUNC_DEF. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 35 line(s). Calls functions: -zplg-stress |-- zplugin-side.zsh/-zplg-exists-physically-message |-- zplugin-side.zsh/-zplg-first `-- zplugin.zsh/-zplg-any-to-user-plugin Uses feature(s): zcompile Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). -zplg-uncompile-plugin # Uncompiles given plugin. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user (+ plugin in $2), plugin) $2 - plugin (only when $1 - i.e. user - given) Has 22 line(s). Calls functions: -zplg-uncompile-plugin |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: -zplg-compile-uncompile-all zplugin.zsh/zplugin -zplg-uninstall-completions # Removes all completions of given plugin from Zshell (i.e. from FPATH). The FPATH is typically `~/.zplugin/completions/'. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 41 line(s). Calls functions: -zplg-uninstall-completions |-- -zplg-get-path | |-- zplugin-side.zsh/-zplg-exists-physically | |-- zplugin-side.zsh/-zplg-shands-exp | |-- zplugin-side.zsh/-zplg-two-paths | `-- zplugin.zsh/-zplg-any-to-user-plugin `-- zplugin-install.zsh/-zplg-forget-completion Called by: zplugin.zsh/zplugin -zplg-unload # 0. Call the Zsh Plugin's Standard *_plugin_unload function 1. Delete bindkeys (...) 2. Delete Zstyles 3. Restore options 4. Remove aliases 5. Restore Zle state 6. Unfunction functions (created by plugin) 7. Clean-up FPATH and PATH 8. Delete created variables 9. Forget the plugin User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 347 line(s). Calls functions: -zplg-unload |-- -zplg-clear-report-for | `-- -zplg-any-to-uspl2 | `-- zplugin.zsh/-zplg-any-to-user-plugin |-- -zplg-diff-env-compute |-- -zplg-diff-functions-compute |-- -zplg-diff-options-compute |-- -zplg-diff-parameter-compute |-- -zplg-exists-message | |-- -zplg-any-to-uspl2 | | `-- zplugin.zsh/-zplg-any-to-user-plugin | `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 |-- -zplg-restore-extendedglob |-- -zplg-save-set-extendedglob |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 |-- zplugin.zsh/-zplg-any-to-user-plugin |-- zplugin.zsh/-zplg-clear-debug-report `-- zplugin.zsh/-zplg-unregister-plugin Uses feature(s): alias , bindkey , unalias , unfunction , zle , zstyle Called by: zplugin.zsh/-zplg-debug-unload zplugin.zsh/-zplg-run-task zplugin.zsh/zplugin -zplg-update-or-status # Updates (git pull) or does `git status' for given plugin. User-action entry point. $1 - \"status\" for status, other for update $2 - plugin spec (4 formats: user---plugin, user/plugin, user (+ plugin in $2), plugin) $3 - plugin (only when $1 - i.e. user - given) Has 212 line(s). Calls functions: -zplg-update-or-status |-- -zplg-at-eval |-- -zplg-compute-ice | |-- zplugin-side.zsh/-zplg-exists-physically-message | |-- zplugin-side.zsh/-zplg-shands-exp | |-- zplugin-side.zsh/-zplg-two-paths | |-- zplugin.zsh/-zplg-any-to-user-plugin | `-- zplugin.zsh/-zplg-pack-ice |-- -zplg-update-or-status-snippet | |-- -zplg-compute-ice | | |-- zplugin-side.zsh/-zplg-exists-physically-message | | |-- zplugin-side.zsh/-zplg-shands-exp | | |-- zplugin-side.zsh/-zplg-two-paths | | |-- zplugin.zsh/-zplg-any-to-user-plugin | | `-- zplugin.zsh/-zplg-pack-ice | `-- zplugin.zsh/-zplg-load-snippet |-- zplugin-install.zsh/-zplg-get-latest-gh-r-version |-- zplugin-install.zsh/-zplg-setup-plugin-dir |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 |-- zplugin-side.zsh/-zplg-exists-physically-message |-- zplugin-side.zsh/-zplg-store-ices |-- zplugin-side.zsh/-zplg-two-paths `-- zplugin.zsh/-zplg-any-to-user-plugin Uses feature(s): kill , read , source , wait Called by: -zplg-update-or-status-all zplugin.zsh/zplugin -zplg-update-or-status-all # Updates (git pull) or does `git status` for all existing plugins. This includes also plugins that are not loaded into Zsh (but exist on disk). Also updates (i.e. redownloads) snippets. User-action entry point. Has 63 line(s). Calls functions: -zplg-update-or-status-all |-- -zplg-update-or-status | |-- -zplg-at-eval | |-- -zplg-compute-ice | | |-- zplugin-side.zsh/-zplg-exists-physically-message | | |-- zplugin-side.zsh/-zplg-shands-exp | | |-- zplugin-side.zsh/-zplg-two-paths | | |-- zplugin.zsh/-zplg-any-to-user-plugin | | `-- zplugin.zsh/-zplg-pack-ice | |-- -zplg-update-or-status-snippet | | |-- -zplg-compute-ice | | | |-- zplugin-side.zsh/-zplg-exists-physically-message | | | |-- zplugin-side.zsh/-zplg-shands-exp | | | |-- zplugin-side.zsh/-zplg-two-paths | | | |-- zplugin.zsh/-zplg-any-to-user-plugin | | | `-- zplugin.zsh/-zplg-pack-ice | | `-- zplugin.zsh/-zplg-load-snippet | |-- zplugin-install.zsh/-zplg-get-latest-gh-r-version | |-- zplugin-install.zsh/-zplg-setup-plugin-dir | |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 | |-- zplugin-side.zsh/-zplg-exists-physically-message | |-- zplugin-side.zsh/-zplg-store-ices | |-- zplugin-side.zsh/-zplg-two-paths | `-- zplugin.zsh/-zplg-any-to-user-plugin |-- -zplg-update-or-status-snippet | |-- -zplg-compute-ice | | |-- zplugin-side.zsh/-zplg-exists-physically-message | | |-- zplugin-side.zsh/-zplg-shands-exp | | |-- zplugin-side.zsh/-zplg-two-paths | | |-- zplugin.zsh/-zplg-any-to-user-plugin | | `-- zplugin.zsh/-zplg-pack-ice | `-- zplugin.zsh/-zplg-load-snippet |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: zplugin.zsh/zplugin -zplg-update-or-status-snippet # Implements update or status operation for snippet given by URL. $1 - \"status\" or \"update\" $2 - snippet URL Has 19 line(s). Calls functions: -zplg-update-or-status-snippet |-- -zplg-compute-ice | |-- zplugin-side.zsh/-zplg-exists-physically-message | |-- zplugin-side.zsh/-zplg-shands-exp | |-- zplugin-side.zsh/-zplg-two-paths | |-- zplugin.zsh/-zplg-any-to-user-plugin | `-- zplugin.zsh/-zplg-pack-ice `-- zplugin.zsh/-zplg-load-snippet Called by: -zplg-update-or-status-all -zplg-update-or-status compinit # Has 549 line(s). Doesn't call other functions. Uses feature(s): autoload , bindkey , eval , read , unfunction , zle , zstyle Called by: -zplg-compinit","title":"zplugin-autoload.zsh"},{"location":"zplugin-autoload.zsh/#zplugin-autoloadzsh1","text":"","title":"zplugin-autoload.zsh(1)"},{"location":"zplugin-autoload.zsh/#name","text":"zplugin-autoload.zsh - a shell script","title":"NAME"},{"location":"zplugin-autoload.zsh/#synopsis","text":"Documentation automatically generated with `zshelldoc'","title":"SYNOPSIS"},{"location":"zplugin-autoload.zsh/#functions","text":"-zplg-any-to-uspl2 -zplg-at-eval -zplg-build-module -zplg-cd -zplg-cdisable -zplg-cenable -zplg-changes -zplg-check-comp-consistency -zplg-check-which-completions-are-enabled -zplg-check-which-completions-are-installed -zplg-clear-completions -zplg-clear-report-for -zplg-compiled -zplg-compile-uncompile-all -zplg-compinit -zplg-compute-ice -zplg-confirm -zplg-create -zplg-delete -zplg-diff-env-compute -zplg-diff-functions-compute -zplg-diff-options-compute -zplg-diff-parameter-compute -zplg-edit -zplg-exists-message -zplg-find-completions-of-plugin -zplg-format-env -zplg-format-functions -zplg-format-options -zplg-format-parameter -zplg-get-completion-owner -zplg-get-completion-owner-uspl2col -zplg-get-path -zplg-glance -zplg-help -zplg-list-bindkeys -zplg-list-compdef-replay -zplg-ls -zplg-module -zplg-prepare-readlink -zplg-recall -zplg-recently -zplg-restore-extendedglob -zplg-save-set-extendedglob -zplg-search-completions -zplg-self-update -zplg-show-all-reports -zplg-show-completions -zplg-show-debug-report -zplg-show-registered-plugins -zplg-show-report -zplg-show-times -zplg-show-zstatus -zplg-stress -zplg-uncompile-plugin -zplg-uninstall-completions -zplg-unload -zplg-update-or-status -zplg-update-or-status-all -zplg-update-or-status-snippet AUTOLOAD compinit","title":"FUNCTIONS"},{"location":"zplugin-autoload.zsh/#details","text":"","title":"DETAILS"},{"location":"zplugin-autoload.zsh/#script_body","text":"Has 5 line(s). No functions are called (may set up e.g. a hook, a Zle widget bound to a key, etc.). Uses feature(s): source","title":"Script Body"},{"location":"zplugin-autoload.zsh/#-zplg-any-to-uspl2","text":"Converts given plugin-spec to format that's used in keys for hash tables. So basically, creates string \"user/plugin\" (this format is called: uspl2). $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - (optional) plugin (only when $1 - i.e. user - given) Has 2 line(s). Calls functions: -zplg-any-to-uspl2 `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: -zplg-clear-report-for -zplg-exists-message","title":"-zplg-any-to-uspl2"},{"location":"zplugin-autoload.zsh/#-zplg-at-eval","text":"Has 1 line(s). Doesn't call other functions. Uses feature(s): eval Called by: -zplg-update-or-status","title":"-zplg-at-eval"},{"location":"zplugin-autoload.zsh/#-zplg-build-module","text":"Performs ./configure && make on the module and displays information how to load the module in .zshrc. Has 27 line(s). Calls functions: -zplg-build-module `-- -zplg-module Uses feature(s): trap Called by: -zplg-module","title":"-zplg-build-module"},{"location":"zplugin-autoload.zsh/#-zplg-cd","text":"Jumps to plugin's directory (in Zplugin's home directory). User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 13 line(s). Calls functions: -zplg-cd `-- -zplg-get-path |-- zplugin-side.zsh/-zplg-exists-physically |-- zplugin-side.zsh/-zplg-shands-exp |-- zplugin-side.zsh/-zplg-two-paths `-- zplugin.zsh/-zplg-any-to-user-plugin Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"-zplg-cd"},{"location":"zplugin-autoload.zsh/#-zplg-cdisable","text":"Enables given installed completion. User-action entry point. $1 - e.g. \"_mkdir\" or \"mkdir\" Has 30 line(s). Calls functions: -zplg-cdisable |-- -zplg-check-comp-consistency |-- -zplg-get-completion-owner-uspl2col | |-- -zplg-get-completion-owner | `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 `-- -zplg-prepare-readlink Called by: zplugin.zsh/zplugin","title":"-zplg-cdisable"},{"location":"zplugin-autoload.zsh/#-zplg-cenable","text":"Disables given installed completion. User-action entry point. $1 - e.g. \"_mkdir\" or \"mkdir\" Has 31 line(s). Calls functions: -zplg-cenable |-- -zplg-check-comp-consistency |-- -zplg-get-completion-owner-uspl2col | |-- -zplg-get-completion-owner | `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 `-- -zplg-prepare-readlink Called by: zplugin.zsh/zplugin","title":"-zplg-cenable"},{"location":"zplugin-autoload.zsh/#-zplg-changes","text":"Shows `git log` of given plugin. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 9 line(s). Calls functions: -zplg-changes |-- zplugin-side.zsh/-zplg-exists-physically-message `-- zplugin.zsh/-zplg-any-to-user-plugin Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"-zplg-changes"},{"location":"zplugin-autoload.zsh/#-zplg-check-comp-consistency","text":"Zplugin creates symlink for each installed completion. This function checks whether given completion (i.e. file like \"_mkdir\") is indeed a symlink. Backup file is a completion that is disabled - has the leading \"_\" removed. $1 - path to completion within plugin's directory $2 - path to backup file within plugin's directory Has 11 line(s). Doesn't call other functions. Called by: -zplg-cdisable -zplg-cenable","title":"-zplg-check-comp-consistency"},{"location":"zplugin-autoload.zsh/#-zplg-check-which-completions-are-enabled","text":"For each argument that each should be a path to completion within a plugin's dir, it checks whether that completion is disabled - returns 0 or 1 on corresponding positions in reply. Uninstalled completions will be reported as \"0\" - i.e. disabled $1, ... - path to completion within plugin's directory Has 11 line(s). Doesn't call other functions. Called by: -zplg-show-report","title":"-zplg-check-which-completions-are-enabled"},{"location":"zplugin-autoload.zsh/#-zplg-check-which-completions-are-installed","text":"For each argument that each should be a path to completion within a plugin's dir, it checks whether that completion is installed - returns 0 or 1 on corresponding positions in reply. $1, ... - path to completion within plugin's directory Has 12 line(s). Doesn't call other functions. Called by: -zplg-show-report","title":"-zplg-check-which-completions-are-installed"},{"location":"zplugin-autoload.zsh/#-zplg-clear-completions","text":"Delete stray and improper completions. Completions live even when plugin isn't loaded - if they are installed and enabled. User-action entry point. Has 37 line(s). Calls functions: -zplg-clear-completions |-- -zplg-get-completion-owner |-- -zplg-prepare-readlink `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 Called by: zplugin.zsh/zplugin","title":"-zplg-clear-completions"},{"location":"zplugin-autoload.zsh/#-zplg-clear-report-for","text":"Clears all report data for given user/plugin. This is done by resetting all related global ZPLG_* hashes. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - (optional) plugin (only when $1 - i.e. user - given) Has 23 line(s). Calls functions: -zplg-clear-report-for `-- -zplg-any-to-uspl2 `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: -zplg-unload zplugin.zsh/-zplg-clear-debug-report","title":"-zplg-clear-report-for"},{"location":"zplugin-autoload.zsh/#-zplg-compiled","text":"Displays list of plugins that are compiled. User-action entry point. Has 26 line(s). Calls functions: -zplg-compiled |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: zplugin.zsh/zplugin","title":"-zplg-compiled"},{"location":"zplugin-autoload.zsh/#-zplg-compile-uncompile-all","text":"Compiles or uncompiles all existing (on disk) plugins. User-action entry point. Has 23 line(s). Calls functions: -zplg-compile-uncompile-all |-- -zplg-uncompile-plugin | |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 | `-- zplugin.zsh/-zplg-any-to-user-plugin |-- zplugin-install.zsh/-zplg-compile-plugin |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: zplugin.zsh/zplugin","title":"-zplg-compile-uncompile-all"},{"location":"zplugin-autoload.zsh/#-zplg-compinit","text":"User-exposed `compinit' frontend which first ensures that all completions managed by Zplugin are forgotten by Zshell. After that it runs normal `compinit', which should more easily detect Zplugin's completions. No arguments. Has 23 line(s). Calls functions: -zplg-compinit |-- compinit `-- zplugin-install.zsh/-zplg-forget-completion Uses feature(s): autoload , unfunction Called by: zplugin.zsh/zplugin","title":"-zplg-compinit"},{"location":"zplugin-autoload.zsh/#-zplg-compute-ice","text":"Computes ZPLG_ICE array (default, it can be specified via $3) from a) input ZPLG_ICE, b) static ice, c) saved ice, taking priorities into account. Also returns path to snippet directory and optional name of snippet file (only valid if ZPLG_ICE[svn] is not set). Can also pack resulting ices into ZPLG_SICE (see $2). $1 - URL (also plugin-spec) $2 - \"pack\" or \"nopack\" or \"pack-nf\" - packing means ZPLG_ICE wins with static ice; \"pack-nf\" means that disk-ices will be ignored (no-file?) $3 - name of output associative array, \"ZPLG_ICE\" is the default $4 - name of output string parameter, to hold path to directory (\"local_dir\") $5 - name of output string parameter, to hold filename (\"filename\") Has 98 line(s). Calls functions: -zplg-compute-ice |-- zplugin-side.zsh/-zplg-exists-physically-message |-- zplugin-side.zsh/-zplg-shands-exp |-- zplugin-side.zsh/-zplg-two-paths |-- zplugin.zsh/-zplg-any-to-user-plugin `-- zplugin.zsh/-zplg-pack-ice Uses feature(s): wait Called by: -zplg-recall -zplg-update-or-status-snippet -zplg-update-or-status","title":"-zplg-compute-ice"},{"location":"zplugin-autoload.zsh/#-zplg-confirm","text":"Prints given question, waits for \"y\" key, evals given expression if \"y\" obtained $1 - question $2 - expression Has 5 line(s). Doesn't call other functions. Uses feature(s): eval , read Called by: -zplg-delete","title":"-zplg-confirm"},{"location":"zplugin-autoload.zsh/#-zplg-create","text":"Creates a plugin, also on Github (if not \"_local/name\" plugin). User-action entry point. $1 - (optional) plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - (optional) plugin (only when $1 - i.e. user - given) Has 66 line(s). Calls functions: -zplg-create |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 |-- zplugin-side.zsh/-zplg-exists-physically `-- zplugin.zsh/-zplg-any-to-user-plugin Uses feature(s): vared Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"-zplg-create"},{"location":"zplugin-autoload.zsh/#-zplg-delete","text":"Deletes plugin's or snippet's directory (in Zplugin's home directory). User-action entry point. $1 - snippet URL or plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 54 line(s). Calls functions: -zplg-delete |-- -zplg-confirm |-- zplugin-side.zsh/-zplg-exists-physically-message |-- zplugin-side.zsh/-zplg-shands-exp |-- zplugin-side.zsh/-zplg-two-paths `-- zplugin.zsh/-zplg-any-to-user-plugin Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"-zplg-delete"},{"location":"zplugin-autoload.zsh/#-zplg-diff-env-compute","text":"Computes ZPLG_PATH, ZPLG_FPATH that hold (f)path components added by plugin. Uses data gathered earlier by -zplg-diff-env(). $1 - user/plugin Has 30 line(s). Doesn't call other functions. Called by: -zplg-show-report -zplg-unload","title":"-zplg-diff-env-compute"},{"location":"zplugin-autoload.zsh/#-zplg-diff-functions-compute","text":"Computes FUNCTIONS that holds new functions added by plugin. Uses data gathered earlier by -zplg-diff-functions(). $1 - user/plugin Has 19 line(s). Doesn't call other functions. Called by: -zplg-show-report -zplg-unload","title":"-zplg-diff-functions-compute"},{"location":"zplugin-autoload.zsh/#-zplg-diff-options-compute","text":"Computes OPTIONS that holds options changed by plugin. Uses data gathered earlier by -zplg-diff-options(). $1 - user/plugin Has 17 line(s). Doesn't call other functions. Called by: -zplg-show-report -zplg-unload","title":"-zplg-diff-options-compute"},{"location":"zplugin-autoload.zsh/#-zplg-diff-parameter-compute","text":"Computes ZPLG_PARAMETERS_PRE, ZPLG_PARAMETERS_POST that hold parameters created or changed (their type) by plugin. Uses data gathered earlier by -zplg-diff-parameter(). $1 - user/plugin Has 28 line(s). Doesn't call other functions. Called by: -zplg-show-report -zplg-unload","title":"-zplg-diff-parameter-compute"},{"location":"zplugin-autoload.zsh/#-zplg-edit","text":"Runs $EDITOR on source of given plugin. If the variable is not set then defaults to `vim'. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 13 line(s). Calls functions: -zplg-edit |-- zplugin-side.zsh/-zplg-exists-physically-message |-- zplugin-side.zsh/-zplg-first `-- zplugin.zsh/-zplg-any-to-user-plugin Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"-zplg-edit"},{"location":"zplugin-autoload.zsh/#-zplg-exists-message","text":"Checks if plugin is loaded. Testable. Also outputs error message if plugin is not loaded. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - (optional) plugin (only when $1 - i.e. user - given) Has 7 line(s). Calls functions: -zplg-exists-message |-- -zplg-any-to-uspl2 | `-- zplugin.zsh/-zplg-any-to-user-plugin `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 Called by: -zplg-show-report -zplg-unload","title":"-zplg-exists-message"},{"location":"zplugin-autoload.zsh/#-zplg-find-completions-of-plugin","text":"Searches for completions owned by given plugin. Returns them in `reply' array. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 6 line(s). Calls functions: -zplg-find-completions-of-plugin `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: -zplg-show-report","title":"-zplg-find-completions-of-plugin"},{"location":"zplugin-autoload.zsh/#-zplg-format-env","text":"Creates one-column text about FPATH or PATH elements added when given plugin was loaded. $1 - user/plugin (i.e. uspl2 format of plugin-spec) $2 - if 1, then examine PATH, if 2, then examine FPATH Has 16 line(s). Doesn't call other functions. Called by: -zplg-show-report","title":"-zplg-format-env"},{"location":"zplugin-autoload.zsh/#-zplg-format-functions","text":"Creates a one or two columns text with functions created by given plugin. $1 - user/plugin (i.e. uspl2 format of plugin-spec) Has 36 line(s). Doesn't call other functions. Called by: -zplg-show-report","title":"-zplg-format-functions"},{"location":"zplugin-autoload.zsh/#-zplg-format-options","text":"Creates one-column text about options that changed when plugin \"$1\" was loaded. $1 - user/plugin (i.e. uspl2 format of plugin-spec) Has 21 line(s). Calls functions: -zplg-format-options |-- -zplg-restore-extendedglob `-- -zplg-save-set-extendedglob Called by: -zplg-show-report","title":"-zplg-format-options"},{"location":"zplugin-autoload.zsh/#-zplg-format-parameter","text":"Creates one column text that lists global parameters that changed when the given plugin was loaded. $1 - user/plugin (i.e. uspl2 format of plugin-spec) Has 34 line(s). Doesn't call other functions. Called by: -zplg-show-report","title":"-zplg-format-parameter"},{"location":"zplugin-autoload.zsh/#-zplg-get-completion-owner","text":"Returns \"user---plugin\" string (uspl1 format) of plugin that owns given completion. Both :A and readlink will be used, then readlink's output if results differ. Readlink might not be available. :A will read the link \"twice\" and give the final repository directory, possibly without username in the uspl format; readlink will read the link \"once\" $1 - absolute path to completion file (in COMPLETIONS_DIR) $2 - readlink command (\":\" or \"readlink\") Has 22 line(s). Doesn't call other functions. Called by: -zplg-clear-completions -zplg-get-completion-owner-uspl2col -zplg-show-completions","title":"-zplg-get-completion-owner"},{"location":"zplugin-autoload.zsh/#-zplg-get-completion-owner-uspl2col","text":"For shortening of code - returns colorized plugin name that owns given completion. $1 - absolute path to completion file (in COMPLETIONS_DIR) $2 - readlink command (\":\" or \"readlink\") Has 2 line(s). Calls functions: -zplg-get-completion-owner-uspl2col |-- -zplg-get-completion-owner `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 Called by: -zplg-cdisable -zplg-cenable","title":"-zplg-get-completion-owner-uspl2col"},{"location":"zplugin-autoload.zsh/#-zplg-get-path","text":"Returns path of given ID-string, which may be a plugin-spec (like \"user/plugin\" or \"user\" \"plugin\"), an absolute path (\"%\" \"/home/...\" and also \"%SNIPPETS/...\" etc.), or a plugin nickname (i.e. id-as'' ice-mod), or a snippet nickname. Has 35 line(s). Calls functions: -zplg-get-path |-- zplugin-side.zsh/-zplg-exists-physically |-- zplugin-side.zsh/-zplg-shands-exp |-- zplugin-side.zsh/-zplg-two-paths `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: -zplg-cd -zplg-uninstall-completions","title":"-zplg-get-path"},{"location":"zplugin-autoload.zsh/#-zplg-glance","text":"Shows colorized source code of plugin. Is able to use pygmentize, highlight, GNU source-highlight. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 39 line(s). Calls functions: -zplg-glance |-- zplugin-side.zsh/-zplg-exists-physically-message |-- zplugin-side.zsh/-zplg-first `-- zplugin.zsh/-zplg-any-to-user-plugin Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"-zplg-glance"},{"location":"zplugin-autoload.zsh/#-zplg-help","text":"Shows usage information. User-action entry point. Has 68 line(s). Doesn't call other functions. Called by: zplugin.zsh/zplugin","title":"-zplg-help"},{"location":"zplugin-autoload.zsh/#-zplg-list-bindkeys","text":"Has 42 line(s). Calls functions: -zplg-list-bindkeys `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 Called by: zplugin.zsh/zplugin","title":"-zplg-list-bindkeys"},{"location":"zplugin-autoload.zsh/#-zplg-list-compdef-replay","text":"Shows recorded compdefs (called by plugins loaded earlier). Plugins often call `compdef' hoping for `compinit' being already ran. Zplugin solves this by recording compdefs. User-action entry point. Has 5 line(s). Doesn't call other functions. Called by: zplugin.zsh/zplugin","title":"-zplg-list-compdef-replay"},{"location":"zplugin-autoload.zsh/#-zplg-ls","text":"Has 19 line(s). Doesn't call other functions. Called by: zplugin.zsh/zplugin","title":"-zplg-ls"},{"location":"zplugin-autoload.zsh/#-zplg-module","text":"Function that has sub-commands passed as long-options (with two dashes, --). It's an attempt to plugin only this one function into `zplugin' function defined in zplugin.zsh, to not make this file longer than it's needed. Has 24 line(s). Calls functions: -zplg-module `-- -zplg-build-module Called by: -zplg-build-module zplugin.zsh/zplugin","title":"-zplg-module"},{"location":"zplugin-autoload.zsh/#-zplg-prepare-readlink","text":"Prepares readlink command, used for establishing completion's owner. $REPLY = \":\" or \"readlink\" Has 4 line(s). Doesn't call other functions. Uses feature(s): type Called by: -zplg-cdisable -zplg-cenable -zplg-clear-completions -zplg-show-completions","title":"-zplg-prepare-readlink"},{"location":"zplugin-autoload.zsh/#-zplg-recall","text":"Has 37 line(s). Calls functions: -zplg-recall `-- -zplg-compute-ice |-- zplugin-side.zsh/-zplg-exists-physically-message |-- zplugin-side.zsh/-zplg-shands-exp |-- zplugin-side.zsh/-zplg-two-paths |-- zplugin.zsh/-zplg-any-to-user-plugin `-- zplugin.zsh/-zplg-pack-ice Uses feature(s): wait Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"-zplg-recall"},{"location":"zplugin-autoload.zsh/#-zplg-recently","text":"Shows plugins that obtained commits in specified past time. User-action entry point. $1 - time spec, e.g. \"1 week\" Has 26 line(s). Calls functions: -zplg-recently `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 Called by: zplugin.zsh/zplugin","title":"-zplg-recently"},{"location":"zplugin-autoload.zsh/#-zplg-restore-extendedglob","text":"Restores extendedglob-option from state saved earlier. Has 1 line(s). Doesn't call other functions. Called by: -zplg-format-options -zplg-show-registered-plugins -zplg-unload","title":"-zplg-restore-extendedglob"},{"location":"zplugin-autoload.zsh/#-zplg-save-set-extendedglob","text":"Enables extendedglob-option first saving if it was already enabled, for restoration of this state later. Has 2 line(s). Doesn't call other functions. Called by: -zplg-format-options -zplg-show-registered-plugins -zplg-unload","title":"-zplg-save-set-extendedglob"},{"location":"zplugin-autoload.zsh/#-zplg-search-completions","text":"While -zplg-show-completions() shows what completions are installed, this functions searches through all plugin dirs showing what's available in general (for installation). User-action entry point. Has 43 line(s). Calls functions: -zplg-search-completions `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 Called by: zplugin.zsh/zplugin","title":"-zplg-search-completions"},{"location":"zplugin-autoload.zsh/#-zplg-self-update","text":"Updates Zplugin code (does a git pull). User-action entry point. Has 23 line(s). Doesn't call other functions. Uses feature(s): zcompile Called by: zplugin.zsh/zplugin","title":"-zplg-self-update"},{"location":"zplugin-autoload.zsh/#-zplg-show-all-reports","text":"Displays reports of all loaded plugins. User-action entry point. Has 5 line(s). Calls functions: -zplg-show-all-reports `-- -zplg-show-report |-- -zplg-check-which-completions-are-enabled |-- -zplg-check-which-completions-are-installed |-- -zplg-diff-env-compute |-- -zplg-diff-functions-compute |-- -zplg-diff-options-compute |-- -zplg-diff-parameter-compute |-- -zplg-exists-message | |-- -zplg-any-to-uspl2 | | `-- zplugin.zsh/-zplg-any-to-user-plugin | `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 |-- -zplg-find-completions-of-plugin | `-- zplugin.zsh/-zplg-any-to-user-plugin |-- -zplg-format-env |-- -zplg-format-functions |-- -zplg-format-options | |-- -zplg-restore-extendedglob | `-- -zplg-save-set-extendedglob |-- -zplg-format-parameter `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: zplugin.zsh/zplugin","title":"-zplg-show-all-reports"},{"location":"zplugin-autoload.zsh/#-zplg-show-completions","text":"Display installed (enabled and disabled), completions. Detect stray and improper ones. Completions live even when plugin isn't loaded - if they are installed and enabled. User-action entry point. Has 72 line(s). Calls functions: -zplg-show-completions |-- -zplg-get-completion-owner |-- -zplg-prepare-readlink `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 Called by: zplugin.zsh/zplugin","title":"-zplg-show-completions"},{"location":"zplugin-autoload.zsh/#-zplg-show-debug-report","text":"Displays dtrace report (data recorded in interactive session). User-action entry point. Has 1 line(s). Calls functions: -zplg-show-debug-report `-- -zplg-show-report |-- -zplg-check-which-completions-are-enabled |-- -zplg-check-which-completions-are-installed |-- -zplg-diff-env-compute |-- -zplg-diff-functions-compute |-- -zplg-diff-options-compute |-- -zplg-diff-parameter-compute |-- -zplg-exists-message | |-- -zplg-any-to-uspl2 | | `-- zplugin.zsh/-zplg-any-to-user-plugin | `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 |-- -zplg-find-completions-of-plugin | `-- zplugin.zsh/-zplg-any-to-user-plugin |-- -zplg-format-env |-- -zplg-format-functions |-- -zplg-format-options | |-- -zplg-restore-extendedglob | `-- -zplg-save-set-extendedglob |-- -zplg-format-parameter `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: zplugin.zsh/zplugin","title":"-zplg-show-debug-report"},{"location":"zplugin-autoload.zsh/#-zplg-show-registered-plugins","text":"Lists loaded plugins (subcommands list, lodaded). User-action entry point. Has 21 line(s). Calls functions: -zplg-show-registered-plugins |-- -zplg-restore-extendedglob |-- -zplg-save-set-extendedglob `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 Called by: zplugin.zsh/zplugin","title":"-zplg-show-registered-plugins"},{"location":"zplugin-autoload.zsh/#-zplg-show-report","text":"Displays report of the plugin given. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user (+ plugin in $2), plugin) $2 - plugin (only when $1 - i.e. user - given) Has 71 line(s). Calls functions: -zplg-show-report |-- -zplg-check-which-completions-are-enabled |-- -zplg-check-which-completions-are-installed |-- -zplg-diff-env-compute |-- -zplg-diff-functions-compute |-- -zplg-diff-options-compute |-- -zplg-diff-parameter-compute |-- -zplg-exists-message | |-- -zplg-any-to-uspl2 | | `-- zplugin.zsh/-zplg-any-to-user-plugin | `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 |-- -zplg-find-completions-of-plugin | `-- zplugin.zsh/-zplg-any-to-user-plugin |-- -zplg-format-env |-- -zplg-format-functions |-- -zplg-format-options | |-- -zplg-restore-extendedglob | `-- -zplg-save-set-extendedglob |-- -zplg-format-parameter `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: -zplg-show-all-reports -zplg-show-debug-report zplugin.zsh/zplugin","title":"-zplg-show-report"},{"location":"zplugin-autoload.zsh/#-zplg-show-times","text":"Shows loading times of all loaded plugins. User-action entry point. Has 42 line(s). Calls functions: -zplg-show-times `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 Called by: zplugin.zsh/zplugin","title":"-zplg-show-times"},{"location":"zplugin-autoload.zsh/#-zplg-show-zstatus","text":"Shows Zplugin status, i.e. number of loaded plugins, of available completions, etc. User-action entry point. Has 41 line(s). Doesn't call other functions. Called by: zplugin.zsh/zplugin","title":"-zplg-show-zstatus"},{"location":"zplugin-autoload.zsh/#-zplg-stress","text":"Compiles plugin with various options on and off to see how well the code is written. The options are: NO_SHORT_LOOPS, IGNORE_BRACES, IGNORE_CLOSE_BRACES, SH_GLOB, CSH_JUNKIE_QUOTES, NO_MULTI_FUNC_DEF. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 35 line(s). Calls functions: -zplg-stress |-- zplugin-side.zsh/-zplg-exists-physically-message |-- zplugin-side.zsh/-zplg-first `-- zplugin.zsh/-zplg-any-to-user-plugin Uses feature(s): zcompile Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"-zplg-stress"},{"location":"zplugin-autoload.zsh/#-zplg-uncompile-plugin","text":"Uncompiles given plugin. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user (+ plugin in $2), plugin) $2 - plugin (only when $1 - i.e. user - given) Has 22 line(s). Calls functions: -zplg-uncompile-plugin |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: -zplg-compile-uncompile-all zplugin.zsh/zplugin","title":"-zplg-uncompile-plugin"},{"location":"zplugin-autoload.zsh/#-zplg-uninstall-completions","text":"Removes all completions of given plugin from Zshell (i.e. from FPATH). The FPATH is typically `~/.zplugin/completions/'. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 41 line(s). Calls functions: -zplg-uninstall-completions |-- -zplg-get-path | |-- zplugin-side.zsh/-zplg-exists-physically | |-- zplugin-side.zsh/-zplg-shands-exp | |-- zplugin-side.zsh/-zplg-two-paths | `-- zplugin.zsh/-zplg-any-to-user-plugin `-- zplugin-install.zsh/-zplg-forget-completion Called by: zplugin.zsh/zplugin","title":"-zplg-uninstall-completions"},{"location":"zplugin-autoload.zsh/#-zplg-unload","text":"0. Call the Zsh Plugin's Standard *_plugin_unload function 1. Delete bindkeys (...) 2. Delete Zstyles 3. Restore options 4. Remove aliases 5. Restore Zle state 6. Unfunction functions (created by plugin) 7. Clean-up FPATH and PATH 8. Delete created variables 9. Forget the plugin User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 347 line(s). Calls functions: -zplg-unload |-- -zplg-clear-report-for | `-- -zplg-any-to-uspl2 | `-- zplugin.zsh/-zplg-any-to-user-plugin |-- -zplg-diff-env-compute |-- -zplg-diff-functions-compute |-- -zplg-diff-options-compute |-- -zplg-diff-parameter-compute |-- -zplg-exists-message | |-- -zplg-any-to-uspl2 | | `-- zplugin.zsh/-zplg-any-to-user-plugin | `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 |-- -zplg-restore-extendedglob |-- -zplg-save-set-extendedglob |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 |-- zplugin.zsh/-zplg-any-to-user-plugin |-- zplugin.zsh/-zplg-clear-debug-report `-- zplugin.zsh/-zplg-unregister-plugin Uses feature(s): alias , bindkey , unalias , unfunction , zle , zstyle Called by: zplugin.zsh/-zplg-debug-unload zplugin.zsh/-zplg-run-task zplugin.zsh/zplugin","title":"-zplg-unload"},{"location":"zplugin-autoload.zsh/#-zplg-update-or-status","text":"Updates (git pull) or does `git status' for given plugin. User-action entry point. $1 - \"status\" for status, other for update $2 - plugin spec (4 formats: user---plugin, user/plugin, user (+ plugin in $2), plugin) $3 - plugin (only when $1 - i.e. user - given) Has 212 line(s). Calls functions: -zplg-update-or-status |-- -zplg-at-eval |-- -zplg-compute-ice | |-- zplugin-side.zsh/-zplg-exists-physically-message | |-- zplugin-side.zsh/-zplg-shands-exp | |-- zplugin-side.zsh/-zplg-two-paths | |-- zplugin.zsh/-zplg-any-to-user-plugin | `-- zplugin.zsh/-zplg-pack-ice |-- -zplg-update-or-status-snippet | |-- -zplg-compute-ice | | |-- zplugin-side.zsh/-zplg-exists-physically-message | | |-- zplugin-side.zsh/-zplg-shands-exp | | |-- zplugin-side.zsh/-zplg-two-paths | | |-- zplugin.zsh/-zplg-any-to-user-plugin | | `-- zplugin.zsh/-zplg-pack-ice | `-- zplugin.zsh/-zplg-load-snippet |-- zplugin-install.zsh/-zplg-get-latest-gh-r-version |-- zplugin-install.zsh/-zplg-setup-plugin-dir |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 |-- zplugin-side.zsh/-zplg-exists-physically-message |-- zplugin-side.zsh/-zplg-store-ices |-- zplugin-side.zsh/-zplg-two-paths `-- zplugin.zsh/-zplg-any-to-user-plugin Uses feature(s): kill , read , source , wait Called by: -zplg-update-or-status-all zplugin.zsh/zplugin","title":"-zplg-update-or-status"},{"location":"zplugin-autoload.zsh/#-zplg-update-or-status-all","text":"Updates (git pull) or does `git status` for all existing plugins. This includes also plugins that are not loaded into Zsh (but exist on disk). Also updates (i.e. redownloads) snippets. User-action entry point. Has 63 line(s). Calls functions: -zplg-update-or-status-all |-- -zplg-update-or-status | |-- -zplg-at-eval | |-- -zplg-compute-ice | | |-- zplugin-side.zsh/-zplg-exists-physically-message | | |-- zplugin-side.zsh/-zplg-shands-exp | | |-- zplugin-side.zsh/-zplg-two-paths | | |-- zplugin.zsh/-zplg-any-to-user-plugin | | `-- zplugin.zsh/-zplg-pack-ice | |-- -zplg-update-or-status-snippet | | |-- -zplg-compute-ice | | | |-- zplugin-side.zsh/-zplg-exists-physically-message | | | |-- zplugin-side.zsh/-zplg-shands-exp | | | |-- zplugin-side.zsh/-zplg-two-paths | | | |-- zplugin.zsh/-zplg-any-to-user-plugin | | | `-- zplugin.zsh/-zplg-pack-ice | | `-- zplugin.zsh/-zplg-load-snippet | |-- zplugin-install.zsh/-zplg-get-latest-gh-r-version | |-- zplugin-install.zsh/-zplg-setup-plugin-dir | |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 | |-- zplugin-side.zsh/-zplg-exists-physically-message | |-- zplugin-side.zsh/-zplg-store-ices | |-- zplugin-side.zsh/-zplg-two-paths | `-- zplugin.zsh/-zplg-any-to-user-plugin |-- -zplg-update-or-status-snippet | |-- -zplg-compute-ice | | |-- zplugin-side.zsh/-zplg-exists-physically-message | | |-- zplugin-side.zsh/-zplg-shands-exp | | |-- zplugin-side.zsh/-zplg-two-paths | | |-- zplugin.zsh/-zplg-any-to-user-plugin | | `-- zplugin.zsh/-zplg-pack-ice | `-- zplugin.zsh/-zplg-load-snippet |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: zplugin.zsh/zplugin","title":"-zplg-update-or-status-all"},{"location":"zplugin-autoload.zsh/#-zplg-update-or-status-snippet","text":"Implements update or status operation for snippet given by URL. $1 - \"status\" or \"update\" $2 - snippet URL Has 19 line(s). Calls functions: -zplg-update-or-status-snippet |-- -zplg-compute-ice | |-- zplugin-side.zsh/-zplg-exists-physically-message | |-- zplugin-side.zsh/-zplg-shands-exp | |-- zplugin-side.zsh/-zplg-two-paths | |-- zplugin.zsh/-zplg-any-to-user-plugin | `-- zplugin.zsh/-zplg-pack-ice `-- zplugin.zsh/-zplg-load-snippet Called by: -zplg-update-or-status-all -zplg-update-or-status","title":"-zplg-update-or-status-snippet"},{"location":"zplugin-autoload.zsh/#compinit","text":"Has 549 line(s). Doesn't call other functions. Uses feature(s): autoload , bindkey , eval , read , unfunction , zle , zstyle Called by: -zplg-compinit","title":"compinit"},{"location":"zplugin-install.zsh/","text":"zplugin-install.zsh(1) # NAME # zplugin-install.zsh - a shell script SYNOPSIS # Documentation automatically generated with `zshelldoc' FUNCTIONS # -zplg-at-eval -zplg-compile-plugin -zplg-download-file-stdout -zplg-download-snippet -zplg-forget-completion -zplg-get-latest-gh-r-version -zplg-handle-binary-file -zplg-install-completions -zplg-mirror-using-svn -zplg-setup-plugin-dir DETAILS # Script Body # Has 3 line(s). No functions are called (may set up e.g. a hook, a Zle widget bound to a key, etc.). Uses feature(s): source -zplg-at-eval # Has 1 line(s). Doesn't call other functions. Uses feature(s): eval Called by: -zplg-download-snippet -zplg-compile-plugin # Compiles given plugin (its main source file, and also an additional \"....zsh\" file if it exists). $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 50 line(s). Calls functions: -zplg-compile-plugin |-- zplugin-side.zsh/-zplg-first `-- zplugin.zsh/-zplg-any-to-user-plugin Uses feature(s): eval , zcompile Called by: -zplg-setup-plugin-dir zplugin-autoload.zsh/-zplg-compile-uncompile-all zplugin.zsh/zplugin -zplg-download-file-stdout # Downloads file to stdout. Supports following backend commands: curl, wget, lftp, lynx. Used by snippet loading. Has 32 line(s). Calls functions: -zplg-download-file-stdout Uses feature(s): type Called by: -zplg-download-snippet -zplg-setup-plugin-dir -zplg-download-snippet # Downloads snippet \u2013 either a file \u2013 with curl, wget, lftp or lynx, or a directory, with Subversion \u2013 when svn-ICE is active. Github supports Subversion protocol and allows to clone subdirectories. This is used to provide a layer of support for Oh-My-Zsh and Prezto. Has 233 line(s). Calls functions: -zplg-download-snippet |-- -zplg-at-eval |-- -zplg-download-file-stdout |-- -zplg-install-completions | |-- -zplg-forget-completion | |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 | |-- zplugin-side.zsh/-zplg-exists-physically-message | `-- zplugin.zsh/-zplg-any-to-user-plugin |-- -zplg-mirror-using-svn `-- zplugin-side.zsh/-zplg-store-ices Uses feature(s): eval , zcompile Called by: zplugin.zsh/-zplg-load-snippet -zplg-forget-completion # Implements alternation of Zsh state so that already initialized completion stops being visible to Zsh. $1 - completion function name, e.g. \"_cp\"; can also be \"cp\" Has 15 line(s). Doesn't call other functions. Uses feature(s): unfunction Called by: -zplg-install-completions zplugin-autoload.zsh/-zplg-compinit zplugin-autoload.zsh/-zplg-uninstall-completions zplugin.zsh/zplugin -zplg-get-latest-gh-r-version # Gets version string of latest release of given Github package. Connects to Github releases page. Has 14 line(s). Calls functions: -zplg-get-latest-gh-r-version `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: zplugin-autoload.zsh/-zplg-update-or-status -zplg-handle-binary-file # If the file is an archive, it is extracted by this function. Next stage is scanning of files with the common utility `file', to detect executables. They are given +x mode. There are also messages to the user on performed actions. $1 - url $2 - file Has 66 line(s). Doesn't call other functions. Uses feature(s): unfunction Called by: -zplg-setup-plugin-dir -zplg-install-completions # Installs all completions of given plugin. After that they are visible to `compinit'. Visible completions can be selectively disabled and enabled. User can access completion data with `clist' or `completions' subcommand. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) $3 - if 1, then reinstall, otherwise only install completions that aren't there Has 34 line(s). Calls functions: -zplg-install-completions |-- -zplg-forget-completion |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 |-- zplugin-side.zsh/-zplg-exists-physically-message `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: -zplg-download-snippet -zplg-setup-plugin-dir zplugin.zsh/zplugin -zplg-mirror-using-svn # Used to clone subdirectories from Github. If in update mode (see $2), then invokes `svn update', in normal mode invokes `svn checkout --non-interactive -q <URL>'. In test mode only compares remote and local revision and outputs true if update is needed. $1 - URL $2 - mode, \"\" - normal, \"-u\" - update, \"-t\" - test $3 - subdirectory (not path) with working copy, needed for -t and -u Has 27 line(s). Doesn't call other functions. Called by: -zplg-download-snippet -zplg-setup-plugin-dir # Clones given plugin into PLUGIN_DIR. Supports multiple sites (respecting `from' and `proto' ice modifiers). Invokes compilation of plugin's main file. $1 - user $2 - plugin Has 182 line(s). Calls functions: -zplg-setup-plugin-dir |-- -zplg-compile-plugin | |-- zplugin-side.zsh/-zplg-first | `-- zplugin.zsh/-zplg-any-to-user-plugin |-- -zplg-download-file-stdout |-- -zplg-handle-binary-file |-- -zplg-install-completions | |-- -zplg-forget-completion | |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 | |-- zplugin-side.zsh/-zplg-exists-physically-message | `-- zplugin.zsh/-zplg-any-to-user-plugin |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 `-- zplugin-side.zsh/-zplg-store-ices Uses feature(s): eval Called by: zplugin-autoload.zsh/-zplg-update-or-status zplugin.zsh/-zplg-load","title":"zplugin-install.zsh"},{"location":"zplugin-install.zsh/#zplugin-installzsh1","text":"","title":"zplugin-install.zsh(1)"},{"location":"zplugin-install.zsh/#name","text":"zplugin-install.zsh - a shell script","title":"NAME"},{"location":"zplugin-install.zsh/#synopsis","text":"Documentation automatically generated with `zshelldoc'","title":"SYNOPSIS"},{"location":"zplugin-install.zsh/#functions","text":"-zplg-at-eval -zplg-compile-plugin -zplg-download-file-stdout -zplg-download-snippet -zplg-forget-completion -zplg-get-latest-gh-r-version -zplg-handle-binary-file -zplg-install-completions -zplg-mirror-using-svn -zplg-setup-plugin-dir","title":"FUNCTIONS"},{"location":"zplugin-install.zsh/#details","text":"","title":"DETAILS"},{"location":"zplugin-install.zsh/#script_body","text":"Has 3 line(s). No functions are called (may set up e.g. a hook, a Zle widget bound to a key, etc.). Uses feature(s): source","title":"Script Body"},{"location":"zplugin-install.zsh/#-zplg-at-eval","text":"Has 1 line(s). Doesn't call other functions. Uses feature(s): eval Called by: -zplg-download-snippet","title":"-zplg-at-eval"},{"location":"zplugin-install.zsh/#-zplg-compile-plugin","text":"Compiles given plugin (its main source file, and also an additional \"....zsh\" file if it exists). $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 50 line(s). Calls functions: -zplg-compile-plugin |-- zplugin-side.zsh/-zplg-first `-- zplugin.zsh/-zplg-any-to-user-plugin Uses feature(s): eval , zcompile Called by: -zplg-setup-plugin-dir zplugin-autoload.zsh/-zplg-compile-uncompile-all zplugin.zsh/zplugin","title":"-zplg-compile-plugin"},{"location":"zplugin-install.zsh/#-zplg-download-file-stdout","text":"Downloads file to stdout. Supports following backend commands: curl, wget, lftp, lynx. Used by snippet loading. Has 32 line(s). Calls functions: -zplg-download-file-stdout Uses feature(s): type Called by: -zplg-download-snippet -zplg-setup-plugin-dir","title":"-zplg-download-file-stdout"},{"location":"zplugin-install.zsh/#-zplg-download-snippet","text":"Downloads snippet \u2013 either a file \u2013 with curl, wget, lftp or lynx, or a directory, with Subversion \u2013 when svn-ICE is active. Github supports Subversion protocol and allows to clone subdirectories. This is used to provide a layer of support for Oh-My-Zsh and Prezto. Has 233 line(s). Calls functions: -zplg-download-snippet |-- -zplg-at-eval |-- -zplg-download-file-stdout |-- -zplg-install-completions | |-- -zplg-forget-completion | |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 | |-- zplugin-side.zsh/-zplg-exists-physically-message | `-- zplugin.zsh/-zplg-any-to-user-plugin |-- -zplg-mirror-using-svn `-- zplugin-side.zsh/-zplg-store-ices Uses feature(s): eval , zcompile Called by: zplugin.zsh/-zplg-load-snippet","title":"-zplg-download-snippet"},{"location":"zplugin-install.zsh/#-zplg-forget-completion","text":"Implements alternation of Zsh state so that already initialized completion stops being visible to Zsh. $1 - completion function name, e.g. \"_cp\"; can also be \"cp\" Has 15 line(s). Doesn't call other functions. Uses feature(s): unfunction Called by: -zplg-install-completions zplugin-autoload.zsh/-zplg-compinit zplugin-autoload.zsh/-zplg-uninstall-completions zplugin.zsh/zplugin","title":"-zplg-forget-completion"},{"location":"zplugin-install.zsh/#-zplg-get-latest-gh-r-version","text":"Gets version string of latest release of given Github package. Connects to Github releases page. Has 14 line(s). Calls functions: -zplg-get-latest-gh-r-version `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: zplugin-autoload.zsh/-zplg-update-or-status","title":"-zplg-get-latest-gh-r-version"},{"location":"zplugin-install.zsh/#-zplg-handle-binary-file","text":"If the file is an archive, it is extracted by this function. Next stage is scanning of files with the common utility `file', to detect executables. They are given +x mode. There are also messages to the user on performed actions. $1 - url $2 - file Has 66 line(s). Doesn't call other functions. Uses feature(s): unfunction Called by: -zplg-setup-plugin-dir","title":"-zplg-handle-binary-file"},{"location":"zplugin-install.zsh/#-zplg-install-completions","text":"Installs all completions of given plugin. After that they are visible to `compinit'. Visible completions can be selectively disabled and enabled. User can access completion data with `clist' or `completions' subcommand. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) $3 - if 1, then reinstall, otherwise only install completions that aren't there Has 34 line(s). Calls functions: -zplg-install-completions |-- -zplg-forget-completion |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 |-- zplugin-side.zsh/-zplg-exists-physically-message `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: -zplg-download-snippet -zplg-setup-plugin-dir zplugin.zsh/zplugin","title":"-zplg-install-completions"},{"location":"zplugin-install.zsh/#-zplg-mirror-using-svn","text":"Used to clone subdirectories from Github. If in update mode (see $2), then invokes `svn update', in normal mode invokes `svn checkout --non-interactive -q <URL>'. In test mode only compares remote and local revision and outputs true if update is needed. $1 - URL $2 - mode, \"\" - normal, \"-u\" - update, \"-t\" - test $3 - subdirectory (not path) with working copy, needed for -t and -u Has 27 line(s). Doesn't call other functions. Called by: -zplg-download-snippet","title":"-zplg-mirror-using-svn"},{"location":"zplugin-install.zsh/#-zplg-setup-plugin-dir","text":"Clones given plugin into PLUGIN_DIR. Supports multiple sites (respecting `from' and `proto' ice modifiers). Invokes compilation of plugin's main file. $1 - user $2 - plugin Has 182 line(s). Calls functions: -zplg-setup-plugin-dir |-- -zplg-compile-plugin | |-- zplugin-side.zsh/-zplg-first | `-- zplugin.zsh/-zplg-any-to-user-plugin |-- -zplg-download-file-stdout |-- -zplg-handle-binary-file |-- -zplg-install-completions | |-- -zplg-forget-completion | |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 | |-- zplugin-side.zsh/-zplg-exists-physically-message | `-- zplugin.zsh/-zplg-any-to-user-plugin |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 `-- zplugin-side.zsh/-zplg-store-ices Uses feature(s): eval Called by: zplugin-autoload.zsh/-zplg-update-or-status zplugin.zsh/-zplg-load","title":"-zplg-setup-plugin-dir"},{"location":"zplugin-side.zsh/","text":"zplugin-side.zsh(1) # NAME # zplugin-side.zsh - a shell script SYNOPSIS # Documentation automatically generated with `zshelldoc' FUNCTIONS # -zplg-any-colorify-as-uspl2 -zplg-exists-physically -zplg-exists-physically-message -zplg-first -zplg-get-plg-dir -zplg-shands-exp -zplg-store-ices -zplg-two-paths DETAILS # Script Body # Has 1 line(s). No functions are called (may set up e.g. a hook, a Zle widget bound to a key, etc.). -zplg-any-colorify-as-uspl2 # Returns ANSI-colorified \"user/plugin\" string, from any supported plugin spec (user---plugin, user/plugin, user plugin, plugin). $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) $REPLY = ANSI-colorified \"user/plugin\" string Has 11 line(s). Calls functions: -zplg-any-colorify-as-uspl2 `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: -zplg-exists-physically-message zplugin-autoload.zsh/-zplg-clear-completions zplugin-autoload.zsh/-zplg-compiled zplugin-autoload.zsh/-zplg-compile-uncompile-all zplugin-autoload.zsh/-zplg-create zplugin-autoload.zsh/-zplg-exists-message zplugin-autoload.zsh/-zplg-get-completion-owner-uspl2col zplugin-autoload.zsh/-zplg-list-bindkeys zplugin-autoload.zsh/-zplg-recently zplugin-autoload.zsh/-zplg-search-completions zplugin-autoload.zsh/-zplg-show-completions zplugin-autoload.zsh/-zplg-show-registered-plugins zplugin-autoload.zsh/-zplg-show-times zplugin-autoload.zsh/-zplg-uncompile-plugin zplugin-autoload.zsh/-zplg-unload zplugin-autoload.zsh/-zplg-update-or-status-all zplugin-autoload.zsh/-zplg-update-or-status zplugin-install.zsh/-zplg-install-completions zplugin-install.zsh/-zplg-setup-plugin-dir -zplg-exists-physically # Checks if directory of given plugin exists in PLUGIN_DIR. Testable. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 10 line(s). Calls functions: -zplg-exists-physically |-- -zplg-shands-exp `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: -zplg-exists-physically-message zplugin-autoload.zsh/-zplg-create zplugin-autoload.zsh/-zplg-get-path -zplg-exists-physically-message # Checks if directory of given plugin exists in PLUGIN_DIR, and outputs error message if it doesn't. Testable. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 11 line(s). Calls functions: -zplg-exists-physically-message |-- -zplg-any-colorify-as-uspl2 | `-- zplugin.zsh/-zplg-any-to-user-plugin |-- -zplg-exists-physically | |-- -zplg-shands-exp | `-- zplugin.zsh/-zplg-any-to-user-plugin `-- -zplg-shands-exp Called by: zplugin-autoload.zsh/-zplg-changes zplugin-autoload.zsh/-zplg-compute-ice zplugin-autoload.zsh/-zplg-delete zplugin-autoload.zsh/-zplg-edit zplugin-autoload.zsh/-zplg-glance zplugin-autoload.zsh/-zplg-stress zplugin-autoload.zsh/-zplg-update-or-status zplugin-install.zsh/-zplg-install-completions -zplg-first # Finds the main file of plugin. There are multiple file name formats, they are ordered in order starting from more correct ones, and matched. -zplg-load-plugin() has similar code parts and doesn't call -zplg-first() \u2013 for performance. Obscure matching is done in -zplg-find-other-matches, here and in -zplg-load(). Obscure = non-standard main-file naming convention. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 17 line(s). Calls functions: -zplg-first |-- -zplg-get-plg-dir |-- zplugin.zsh/-zplg-any-to-user-plugin `-- zplugin.zsh/-zplg-find-other-matches Called by: zplugin-autoload.zsh/-zplg-edit zplugin-autoload.zsh/-zplg-glance zplugin-autoload.zsh/-zplg-stress zplugin-install.zsh/-zplg-compile-plugin -zplg-get-plg-dir # Has 9 line(s). Doesn't call other functions. Called by: -zplg-first -zplg-shands-exp # Does expansion of currently little unstandarized shorthands like \"%SNIPPETS\", \"%HOME\", \"OMZ::\", \"PZT::\". Has 3 line(s). Doesn't call other functions. Called by: -zplg-exists-physically-message -zplg-exists-physically zplugin-autoload.zsh/-zplg-compute-ice zplugin-autoload.zsh/-zplg-delete zplugin-autoload.zsh/-zplg-get-path -zplg-store-ices # Saves ice mods in given hash onto disk. $1 - directory where to create / delete files $2 - name of hash that holds values $3 - additional keys of hash to store, space separated $4 - additional keys of hash to store, empty-meaningful ices, space separated Has 30 line(s). Doesn't call other functions. Uses feature(s): wait Called by: zplugin-autoload.zsh/-zplg-update-or-status zplugin-install.zsh/-zplg-download-snippet zplugin-install.zsh/-zplg-setup-plugin-dir -zplg-two-paths # Obtains a snippet URL without specification if it is an SVN URL (points to directory) or regular URL (points to file), returns 2 possible paths for further examination Has 19 line(s). Doesn't call other functions. Called by: zplugin-autoload.zsh/-zplg-compute-ice zplugin-autoload.zsh/-zplg-delete zplugin-autoload.zsh/-zplg-get-path zplugin-autoload.zsh/-zplg-update-or-status","title":"zplugin-side.zsh"},{"location":"zplugin-side.zsh/#zplugin-sidezsh1","text":"","title":"zplugin-side.zsh(1)"},{"location":"zplugin-side.zsh/#name","text":"zplugin-side.zsh - a shell script","title":"NAME"},{"location":"zplugin-side.zsh/#synopsis","text":"Documentation automatically generated with `zshelldoc'","title":"SYNOPSIS"},{"location":"zplugin-side.zsh/#functions","text":"-zplg-any-colorify-as-uspl2 -zplg-exists-physically -zplg-exists-physically-message -zplg-first -zplg-get-plg-dir -zplg-shands-exp -zplg-store-ices -zplg-two-paths","title":"FUNCTIONS"},{"location":"zplugin-side.zsh/#details","text":"","title":"DETAILS"},{"location":"zplugin-side.zsh/#script_body","text":"Has 1 line(s). No functions are called (may set up e.g. a hook, a Zle widget bound to a key, etc.).","title":"Script Body"},{"location":"zplugin-side.zsh/#-zplg-any-colorify-as-uspl2","text":"Returns ANSI-colorified \"user/plugin\" string, from any supported plugin spec (user---plugin, user/plugin, user plugin, plugin). $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) $REPLY = ANSI-colorified \"user/plugin\" string Has 11 line(s). Calls functions: -zplg-any-colorify-as-uspl2 `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: -zplg-exists-physically-message zplugin-autoload.zsh/-zplg-clear-completions zplugin-autoload.zsh/-zplg-compiled zplugin-autoload.zsh/-zplg-compile-uncompile-all zplugin-autoload.zsh/-zplg-create zplugin-autoload.zsh/-zplg-exists-message zplugin-autoload.zsh/-zplg-get-completion-owner-uspl2col zplugin-autoload.zsh/-zplg-list-bindkeys zplugin-autoload.zsh/-zplg-recently zplugin-autoload.zsh/-zplg-search-completions zplugin-autoload.zsh/-zplg-show-completions zplugin-autoload.zsh/-zplg-show-registered-plugins zplugin-autoload.zsh/-zplg-show-times zplugin-autoload.zsh/-zplg-uncompile-plugin zplugin-autoload.zsh/-zplg-unload zplugin-autoload.zsh/-zplg-update-or-status-all zplugin-autoload.zsh/-zplg-update-or-status zplugin-install.zsh/-zplg-install-completions zplugin-install.zsh/-zplg-setup-plugin-dir","title":"-zplg-any-colorify-as-uspl2"},{"location":"zplugin-side.zsh/#-zplg-exists-physically","text":"Checks if directory of given plugin exists in PLUGIN_DIR. Testable. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 10 line(s). Calls functions: -zplg-exists-physically |-- -zplg-shands-exp `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: -zplg-exists-physically-message zplugin-autoload.zsh/-zplg-create zplugin-autoload.zsh/-zplg-get-path","title":"-zplg-exists-physically"},{"location":"zplugin-side.zsh/#-zplg-exists-physically-message","text":"Checks if directory of given plugin exists in PLUGIN_DIR, and outputs error message if it doesn't. Testable. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 11 line(s). Calls functions: -zplg-exists-physically-message |-- -zplg-any-colorify-as-uspl2 | `-- zplugin.zsh/-zplg-any-to-user-plugin |-- -zplg-exists-physically | |-- -zplg-shands-exp | `-- zplugin.zsh/-zplg-any-to-user-plugin `-- -zplg-shands-exp Called by: zplugin-autoload.zsh/-zplg-changes zplugin-autoload.zsh/-zplg-compute-ice zplugin-autoload.zsh/-zplg-delete zplugin-autoload.zsh/-zplg-edit zplugin-autoload.zsh/-zplg-glance zplugin-autoload.zsh/-zplg-stress zplugin-autoload.zsh/-zplg-update-or-status zplugin-install.zsh/-zplg-install-completions","title":"-zplg-exists-physically-message"},{"location":"zplugin-side.zsh/#-zplg-first","text":"Finds the main file of plugin. There are multiple file name formats, they are ordered in order starting from more correct ones, and matched. -zplg-load-plugin() has similar code parts and doesn't call -zplg-first() \u2013 for performance. Obscure matching is done in -zplg-find-other-matches, here and in -zplg-load(). Obscure = non-standard main-file naming convention. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 17 line(s). Calls functions: -zplg-first |-- -zplg-get-plg-dir |-- zplugin.zsh/-zplg-any-to-user-plugin `-- zplugin.zsh/-zplg-find-other-matches Called by: zplugin-autoload.zsh/-zplg-edit zplugin-autoload.zsh/-zplg-glance zplugin-autoload.zsh/-zplg-stress zplugin-install.zsh/-zplg-compile-plugin","title":"-zplg-first"},{"location":"zplugin-side.zsh/#-zplg-get-plg-dir","text":"Has 9 line(s). Doesn't call other functions. Called by: -zplg-first","title":"-zplg-get-plg-dir"},{"location":"zplugin-side.zsh/#-zplg-shands-exp","text":"Does expansion of currently little unstandarized shorthands like \"%SNIPPETS\", \"%HOME\", \"OMZ::\", \"PZT::\". Has 3 line(s). Doesn't call other functions. Called by: -zplg-exists-physically-message -zplg-exists-physically zplugin-autoload.zsh/-zplg-compute-ice zplugin-autoload.zsh/-zplg-delete zplugin-autoload.zsh/-zplg-get-path","title":"-zplg-shands-exp"},{"location":"zplugin-side.zsh/#-zplg-store-ices","text":"Saves ice mods in given hash onto disk. $1 - directory where to create / delete files $2 - name of hash that holds values $3 - additional keys of hash to store, space separated $4 - additional keys of hash to store, empty-meaningful ices, space separated Has 30 line(s). Doesn't call other functions. Uses feature(s): wait Called by: zplugin-autoload.zsh/-zplg-update-or-status zplugin-install.zsh/-zplg-download-snippet zplugin-install.zsh/-zplg-setup-plugin-dir","title":"-zplg-store-ices"},{"location":"zplugin-side.zsh/#-zplg-two-paths","text":"Obtains a snippet URL without specification if it is an SVN URL (points to directory) or regular URL (points to file), returns 2 possible paths for further examination Has 19 line(s). Doesn't call other functions. Called by: zplugin-autoload.zsh/-zplg-compute-ice zplugin-autoload.zsh/-zplg-delete zplugin-autoload.zsh/-zplg-get-path zplugin-autoload.zsh/-zplg-update-or-status","title":"-zplg-two-paths"},{"location":"zplugin.zsh/","text":"zplugin.zsh(1) # NAME # zplugin.zsh - a shell script SYNOPSIS # Documentation automatically generated with `zshelldoc' FUNCTIONS # pmodload zpcdclear zpcdreplay zpcompdef zpcompinit -zplg-add-report -zplg-any-to-user-plugin -zplg-clear-debug-report -zplg-compdef-clear -zplg-compdef-replay -zplg-debug-start -zplg-debug-stop -zplg-debug-unload -zplg-deploy-message -zplg-diff -zplg-diff-env -zplg-diff-functions -zplg-diff-options -zplg-diff-parameter -zplg-find-other-matches -zplg-ice -zplg-load -zplg-load-plugin -zplg-load-snippet -zplg-pack-ice -zplg-prepare-home -zplg-register-plugin @zplg-register-z-plugin --zplg-reload-and-run -zplg-run-task -zplg-service --zplg-shadow-alias --zplg-shadow-autoload --zplg-shadow-bindkey --zplg-shadow-compdef -zplg-shadow-off -zplg-shadow-on --zplg-shadow-zle --zplg-shadow-zstyle -zplg-submit-turbo -zplg-unregister-plugin -zplg-wrap-track-functions zplugin -zplugin_scheduler_add_sh AUTOLOAD add-zsh-hook AUTOLOAD compinit AUTOLOAD is-at-least PRECMD-HOOK -zplg-scheduler DETAILS # Script Body # Has 117 line(s). Calls functions: Script-Body |-- add-zsh-hook |-- is-at-least `-- -zplg-prepare-home Uses feature(s): alias , autoload , export , zmodload , zstyle Exports (environment): ZPFX pmodload # Compatibility with Prezto. Calls can be recursive. Has 9 line(s). Calls functions: pmodload `-- -zplg-load-snippet |-- -zplg-deploy-message |-- -zplg-pack-ice |-- -zplg-wrap-track-functions `-- zplugin-install.zsh/-zplg-download-snippet Uses feature(s): zstyle Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). zpcdclear # A wrapper for `zplugin cdclear -q' which can be called from hook ices like the atinit'', atload'', etc. ices. Has 1 line(s). Calls functions: zpcdclear `-- -zplg-compdef-clear Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). zpcdreplay # A function that can be invoked from within `atinit', `atload', etc. ice-mod. It works like `zplugin cdreplay', which cannot be invoked from such hook ices. Has 1 line(s). Calls functions: zpcdreplay `-- -zplg-compdef-replay Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). zpcompdef # Stores compdef for a replay with `zpcdreplay' (turbo mode) or with `zplugin cdreplay' (normal mode). An utility functton of an undefined use case. Has 1 line(s). Doesn't call other functions. Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). zpcompinit # A function that can be invoked from within `atinit', `atload', etc. ice-mod. It runs `autoload compinit; compinit' and respects ZPLGM[ZCOMPDUMP_PATH] and ZPLGM[COMPINIT_OPTS]. Has 1 line(s). Calls functions: zpcompinit `-- compinit Uses feature(s): autoload Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). -zplg-add-report # Adds a report line for given plugin. $1 - uspl2, i.e. user/plugin $2, ... - the text Has 2 line(s). Doesn't call other functions. Called by: -zplg-load-plugin --zplg-shadow-alias --zplg-shadow-autoload --zplg-shadow-bindkey --zplg-shadow-compdef --zplg-shadow-zle --zplg-shadow-zstyle -zplg-any-to-user-plugin # Allows elastic plugin-spec across the code. $1 - plugin spec (2 formats: user/plugin, user plugin) $2 - plugin (only when $1 - i.e. user - given) Returns user and plugin in $reply Has 23 line(s). Doesn't call other functions. Called by: -zplg-load -zplg-unregister-plugin zplugin-autoload.zsh/-zplg-any-to-uspl2 zplugin-autoload.zsh/-zplg-changes zplugin-autoload.zsh/-zplg-compiled zplugin-autoload.zsh/-zplg-compile-uncompile-all zplugin-autoload.zsh/-zplg-compute-ice zplugin-autoload.zsh/-zplg-create zplugin-autoload.zsh/-zplg-delete zplugin-autoload.zsh/-zplg-edit zplugin-autoload.zsh/-zplg-find-completions-of-plugin zplugin-autoload.zsh/-zplg-get-path zplugin-autoload.zsh/-zplg-glance zplugin-autoload.zsh/-zplg-show-report zplugin-autoload.zsh/-zplg-stress zplugin-autoload.zsh/-zplg-uncompile-plugin zplugin-autoload.zsh/-zplg-unload zplugin-autoload.zsh/-zplg-update-or-status-all zplugin-autoload.zsh/-zplg-update-or-status zplugin-install.zsh/-zplg-compile-plugin zplugin-install.zsh/-zplg-get-latest-gh-r-version zplugin-install.zsh/-zplg-install-completions zplugin-side.zsh/-zplg-any-colorify-as-uspl2 zplugin-side.zsh/-zplg-exists-physically zplugin-side.zsh/-zplg-first -zplg-clear-debug-report # Forgets dtrace repport gathered up to this moment. Has 1 line(s). Calls functions: -zplg-clear-debug-report `-- zplugin-autoload.zsh/-zplg-clear-report-for Called by: zplugin zplugin-autoload.zsh/-zplg-unload -zplg-compdef-clear # Implements user-exposed functionality to clear gathered compdefs. Has 3 line(s). Doesn't call other functions. Called by: zpcdclear zplugin -zplg-compdef-replay # Runs gathered compdef calls. This allows to run `compinit' after loading plugins. Has 16 line(s). Doesn't call other functions. Called by: zpcdreplay zplugin -zplg-debug-start # Starts Dtrace, i.e. session tracking for changes in Zsh state. Has 9 line(s). Calls functions: -zplg-debug-start |-- -zplg-diff | |-- -zplg-diff-env | |-- -zplg-diff-functions | |-- -zplg-diff-options | `-- -zplg-diff-parameter `-- -zplg-shadow-on Called by: zplugin -zplg-debug-stop # Stops Dtrace, i.e. session tracking for changes in Zsh state. Has 3 line(s). Calls functions: -zplg-debug-stop |-- -zplg-diff | |-- -zplg-diff-env | |-- -zplg-diff-functions | |-- -zplg-diff-options | `-- -zplg-diff-parameter `-- -zplg-shadow-off Called by: zplugin -zplg-debug-unload # Reverts changes detected by dtrace run. Has 5 line(s). Calls functions: -zplg-debug-unload `-- zplugin-autoload.zsh/-zplg-unload Called by: zplugin -zplg-deploy-message # Deploys a sub-prompt message to be displayed OR a `zle .reset-prompt' call to be invoked Has 12 line(s). Doesn't call other functions. Uses feature(s): read , zle Called by: -zplg-load-snippet -zplg-load -zplg-diff # Performs diff actions of all types Has 4 line(s). Calls functions: -zplg-diff |-- -zplg-diff-env |-- -zplg-diff-functions |-- -zplg-diff-options `-- -zplg-diff-parameter Called by: -zplg-debug-start -zplg-debug-stop -zplg-load-plugin -zplg-diff-env # Implements detection of change in PATH and FPATH. $1 - user/plugin (i.e. uspl2 format) $2 - command, can be \"begin\" or \"end\" Has 18 line(s). Doesn't call other functions. Called by: -zplg-diff -zplg-load-plugin -zplg-diff-functions # Implements detection of newly created functions. Performs data gathering, computation is done in *-compute(). $1 - user/plugin (i.e. uspl2 format) $2 - command, can be \"begin\" or \"end\" Has 8 line(s). Doesn't call other functions. Called by: -zplg-diff -zplg-diff-options # Implements detection of change in option state. Performs data gathering, computation is done in *-compute(). $1 - user/plugin (i.e. uspl2 format) $2 - command, can be \"begin\" or \"end\" Has 7 line(s). Doesn't call other functions. Called by: -zplg-diff -zplg-diff-parameter # Implements detection of change in any parameter's existence and type. Performs data gathering, computation is done in *-compute(). $1 - user/plugin (i.e. uspl2 format) $2 - command, can be \"begin\" or \"end\" Has 9 line(s). Doesn't call other functions. Called by: -zplg-diff -zplg-find-other-matches # Plugin's main source file is in general `name.plugin.zsh'. However, there can be different conventions, if that file is not found, then this functions examines other conventions in order of most expected sanity. Has 14 line(s). Doesn't call other functions. Called by: -zplg-load-plugin zplugin-side.zsh/-zplg-first -zplg-ice # Parses ICE specification (`zplg ice' subcommand), puts the result into ZPLG_ICE global hash. The ice-spec is valid for next command only (i.e. it \"melts\"), but it can then stick to plugin and activate e.g. at update. Has 8 line(s). Doesn't call other functions. Called by: zplugin Environment variables used: ZPFX -zplg-load # Implements the exposed-to-user action of loading a plugin. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin name, if the third format is used Has 42 line(s). Calls functions: -zplg-load |-- -zplg-any-to-user-plugin |-- -zplg-deploy-message |-- -zplg-load-plugin | |-- -zplg-add-report | |-- -zplg-diff | | |-- -zplg-diff-env | | |-- -zplg-diff-functions | | |-- -zplg-diff-options | | `-- -zplg-diff-parameter | |-- -zplg-diff-env | |-- -zplg-find-other-matches | |-- -zplg-shadow-off | |-- -zplg-shadow-on | `-- -zplg-wrap-track-functions |-- -zplg-pack-ice |-- -zplg-register-plugin `-- zplugin-install.zsh/-zplg-setup-plugin-dir Uses feature(s): eval , source , zle Called by: -zplg-run-task -zplg-service zplugin -zplg-load-plugin # Lower-level function for loading a plugin. $1 - user $2 - plugin $3 - mode (light or load) Has 96 line(s). Calls functions: -zplg-load-plugin |-- -zplg-add-report |-- -zplg-diff | |-- -zplg-diff-env | |-- -zplg-diff-functions | |-- -zplg-diff-options | `-- -zplg-diff-parameter |-- -zplg-diff-env |-- -zplg-find-other-matches |-- -zplg-shadow-off |-- -zplg-shadow-on `-- -zplg-wrap-track-functions Uses feature(s): eval , source , zle Called by: -zplg-load -zplg-load-snippet # Implements the exposed-to-user action of loading a snippet. $1 - url (can be local, absolute path) Has 180 line(s). Calls functions: -zplg-load-snippet |-- -zplg-deploy-message |-- -zplg-pack-ice |-- -zplg-wrap-track-functions `-- zplugin-install.zsh/-zplg-download-snippet Uses feature(s): autoload , eval , source , unfunction , zparseopts , zstyle Called by: pmodload -zplg-run-task -zplg-service zplugin zplugin-autoload.zsh/-zplg-update-or-status-snippet -zplg-pack-ice # Remembers all ice-mods, assigns them to concrete plugin. Ice spec is in general forgotten for second-next command (that's why it's called \"ice\" - it melts), however they glue to the object (plugin or snippet) mentioned in the next command \u2013 for later use with e.g. `zplugin update ...' Has 3 line(s). Doesn't call other functions. Called by: -zplg-load-snippet -zplg-load zplugin-autoload.zsh/-zplg-compute-ice -zplg-prepare-home # Creates all directories needed by Zplugin, first checks if they already exist. Has 28 line(s). Doesn't call other functions. Called by: Script-Body Environment variables used: ZPFX -zplg-register-plugin # Adds the plugin to ZPLG_REGISTERED_PLUGINS array and to the zsh_loaded_plugins array (managed according to the plugin standard: http://zdharma.org/Zsh-100-Commits-Club/Zsh-Plugin-Standard.html) Has 23 line(s). Doesn't call other functions. Called by: -zplg-load @zplg-register-z-plugin # Registers the z-plugin inside Zplugin \u2013 i.e. an Zplugin extension Has 4 line(s). Doesn't call other functions. Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). --zplg-reload-and-run # Marks given function ($3) for autoloading, and executes it triggering the load. $1 is the fpath dedicated to the function, $2 are autoload options. This function replaces \"autoload -X\", because using that on older Zsh versions causes problems with traps. So basically one creates function stub that calls --zplg-reload-and-run() instead of \"autoload -X\". $1 - FPATH dedicated to function $2 - autoload options $3 - function name (one that needs autoloading) Author: Bart Schaefer Has 7 line(s). Doesn't call other functions. Uses feature(s): autoload , unfunction Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). -zplg-run-task # A backend, worker function of -zplg-scheduler. It obtains the tasks index and a few of its properties (like the type: plugin, snippet, service plugin, service snippet) and executes it first checking for additional conditions (like non-numeric wait'' ice). $1 - the pass number, either 1st or 2nd pass $2 - the time assigned to the task $3 - type: plugin, snippet, service plugin, service snippet $4 - task's index in the ZPLGM[WAIT_ICE_...] fields $5 - mode: load or light $6 - the plugin-spec or snippet URL or alias name (from id-as'') Has 41 line(s). Calls functions: -zplg-run-task |-- -zplg-load | |-- -zplg-any-to-user-plugin | |-- -zplg-deploy-message | |-- -zplg-load-plugin | | |-- -zplg-add-report | | |-- -zplg-diff | | | |-- -zplg-diff-env | | | |-- -zplg-diff-functions | | | |-- -zplg-diff-options | | | `-- -zplg-diff-parameter | | |-- -zplg-diff-env | | |-- -zplg-find-other-matches | | |-- -zplg-shadow-off | | |-- -zplg-shadow-on | | `-- -zplg-wrap-track-functions | |-- -zplg-pack-ice | |-- -zplg-register-plugin | `-- zplugin-install.zsh/-zplg-setup-plugin-dir |-- -zplg-load-snippet | |-- -zplg-deploy-message | |-- -zplg-pack-ice | |-- -zplg-wrap-track-functions | `-- zplugin-install.zsh/-zplg-download-snippet `-- zplugin-autoload.zsh/-zplg-unload Uses feature(s): eval , source , zle , zpty Called by: -zplg-scheduler -zplg-scheduler # Searches for timeout tasks, executes them. There's an array of tasks waiting for execution, this scheduler manages them, detects which ones should be run at current moment, decides to remove (or not) them from the array after execution. $1 - if \"following\", then it is non-first (second and more) invocation of the scheduler; this results in chain of `sched' invocations that results in repetitive -zplg-scheduler activity if \"burst\", then all tasks are marked timeout and executed one by one; this is handy if e.g. a docker image starts up and needs to install all turbo-mode plugins without any hesitation (delay), i.e. \"burst\" allows to run package installations from script, not from prompt Has 62 line(s). Is a precmd hook . Calls functions: -zplg-scheduler |-- add-zsh-hook `-- -zplg-run-task |-- -zplg-load | |-- -zplg-any-to-user-plugin | |-- -zplg-deploy-message | |-- -zplg-load-plugin | | |-- -zplg-add-report | | |-- -zplg-diff | | | |-- -zplg-diff-env | | | |-- -zplg-diff-functions | | | |-- -zplg-diff-options | | | `-- -zplg-diff-parameter | | |-- -zplg-diff-env | | |-- -zplg-find-other-matches | | |-- -zplg-shadow-off | | |-- -zplg-shadow-on | | `-- -zplg-wrap-track-functions | |-- -zplg-pack-ice | |-- -zplg-register-plugin | `-- zplugin-install.zsh/-zplg-setup-plugin-dir |-- -zplg-load-snippet | |-- -zplg-deploy-message | |-- -zplg-pack-ice | |-- -zplg-wrap-track-functions | `-- zplugin-install.zsh/-zplg-download-snippet `-- zplugin-autoload.zsh/-zplg-unload Uses feature(s): sched , zle Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). -zplg-service # Handles given service, i.e. obtains lock, runs it, or waits if no lock $1 - type \"p\" or \"s\" (plugin or snippet) $2 - mode - for plugin (light or load) $3 - id - URL or plugin ID or alias name (from id-as'') Has 30 line(s). Calls functions: -zplg-service |-- -zplg-load | |-- -zplg-any-to-user-plugin | |-- -zplg-deploy-message | |-- -zplg-load-plugin | | |-- -zplg-add-report | | |-- -zplg-diff | | | |-- -zplg-diff-env | | | |-- -zplg-diff-functions | | | |-- -zplg-diff-options | | | `-- -zplg-diff-parameter | | |-- -zplg-diff-env | | |-- -zplg-find-other-matches | | |-- -zplg-shadow-off | | |-- -zplg-shadow-on | | `-- -zplg-wrap-track-functions | |-- -zplg-pack-ice | |-- -zplg-register-plugin | `-- zplugin-install.zsh/-zplg-setup-plugin-dir `-- -zplg-load-snippet |-- -zplg-deploy-message |-- -zplg-pack-ice |-- -zplg-wrap-track-functions `-- zplugin-install.zsh/-zplg-download-snippet Uses feature(s): kill , read Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). --zplg-shadow-alias # Function defined to hijack plugin's calls to `alias' builtin. The hijacking is to gather report data (which is used in unload). Has 34 line(s). Calls functions: --zplg-shadow-alias `-- -zplg-add-report Uses feature(s): alias , zparseopts Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). --zplg-shadow-autoload # Function defined to hijack plugin's calls to `autoload' builtin. The hijacking is not only to gather report data, but also to run custom `autoload' function, that doesn't need FPATH. Has 48 line(s). Calls functions: --zplg-shadow-autoload `-- -zplg-add-report Uses feature(s): autoload , eval , zparseopts Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). --zplg-shadow-bindkey # Function defined to hijack plugin's calls to `bindkey' builtin. The hijacking is to gather report data (which is used in unload). Has 104 line(s). Calls functions: --zplg-shadow-bindkey |-- is-at-least `-- -zplg-add-report Uses feature(s): bindkey , zparseopts Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). --zplg-shadow-compdef # Function defined to hijack plugin's calls to `compdef' function. The hijacking is not only for reporting, but also to save compdef calls so that `compinit' can be called after loading plugins. Has 4 line(s). Calls functions: --zplg-shadow-compdef `-- -zplg-add-report Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). -zplg-shadow-off # Turn off shadowing completely for a given mode (\"load\", \"light\", \"light-b\" (i.e. the `trackbinds' mode) or \"compdef\"). Has 18 line(s). Doesn't call other functions. Uses feature(s): unfunction Called by: -zplg-debug-stop -zplg-load-plugin -zplg-shadow-on # Turn on shadowing of builtins and functions according to passed mode (\"load\", \"light\", \"light-b\" or \"compdef\"). The shadowing is to gather report data, and to hijack `autoload', `bindkey' and `compdef' calls. Has 25 line(s). Doesn't call other functions. Called by: -zplg-debug-start -zplg-load-plugin --zplg-shadow-zle # Function defined to hijack plugin's calls to `zle' builtin. The hijacking is to gather report data (which is used in unload). Has 38 line(s). Calls functions: --zplg-shadow-zle `-- -zplg-add-report Uses feature(s): zle Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). --zplg-shadow-zstyle # Function defined to hijack plugin's calls to `zstyle' builtin. The hijacking is to gather report data (which is used in unload). Has 21 line(s). Calls functions: --zplg-shadow-zstyle `-- -zplg-add-report Uses feature(s): zparseopts , zstyle Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). -zplg-submit-turbo # If `zplugin load`, `zplugin light` or `zplugin snippet` will be preceded with `wait', `load', `unload' or `on-update-of`/`subscribe' ice-mods then the plugin or snipped is to be loaded in turbo-mode, and this function adds it to internal data structures, so that -zplg-scheduler can run (load, unload) this as a task. Has 14 line(s). Doesn't call other functions. Called by: zplugin -zplg-unregister-plugin # Removes the plugin from ZPLG_REGISTERED_PLUGINS array and from the zsh_loaded_plugins array (managed according to the plugin standard) Has 5 line(s). Calls functions: -zplg-unregister-plugin `-- -zplg-any-to-user-plugin Called by: zplugin-autoload.zsh/-zplg-unload -zplg-wrap-track-functions # Has 19 line(s). Doesn't call other functions. Uses feature(s): eval Called by: -zplg-load-plugin -zplg-load-snippet zplugin # Main function directly exposed to user, obtains subcommand and its arguments, has completion. Has 290 line(s). Calls functions: zplugin |-- compinit |-- -zplg-clear-debug-report | `-- zplugin-autoload.zsh/-zplg-clear-report-for |-- -zplg-compdef-clear |-- -zplg-compdef-replay |-- -zplg-debug-start | |-- -zplg-diff | | |-- -zplg-diff-env | | |-- -zplg-diff-functions | | |-- -zplg-diff-options | | `-- -zplg-diff-parameter | `-- -zplg-shadow-on |-- -zplg-debug-stop | |-- -zplg-diff | | |-- -zplg-diff-env | | |-- -zplg-diff-functions | | |-- -zplg-diff-options | | `-- -zplg-diff-parameter | `-- -zplg-shadow-off |-- -zplg-debug-unload | `-- zplugin-autoload.zsh/-zplg-unload |-- -zplg-ice |-- -zplg-load | |-- -zplg-any-to-user-plugin | |-- -zplg-deploy-message | |-- -zplg-load-plugin | | |-- -zplg-add-report | | |-- -zplg-diff | | | |-- -zplg-diff-env | | | |-- -zplg-diff-functions | | | |-- -zplg-diff-options | | | `-- -zplg-diff-parameter | | |-- -zplg-diff-env | | |-- -zplg-find-other-matches | | |-- -zplg-shadow-off | | |-- -zplg-shadow-on | | `-- -zplg-wrap-track-functions | |-- -zplg-pack-ice | |-- -zplg-register-plugin | `-- zplugin-install.zsh/-zplg-setup-plugin-dir |-- -zplg-load-snippet | |-- -zplg-deploy-message | |-- -zplg-pack-ice | |-- -zplg-wrap-track-functions | `-- zplugin-install.zsh/-zplg-download-snippet |-- -zplg-submit-turbo |-- zplugin-autoload.zsh/-zplg-cdisable |-- zplugin-autoload.zsh/-zplg-cenable |-- zplugin-autoload.zsh/-zplg-clear-completions |-- zplugin-autoload.zsh/-zplg-compiled |-- zplugin-autoload.zsh/-zplg-compile-uncompile-all |-- zplugin-autoload.zsh/-zplg-compinit |-- zplugin-autoload.zsh/-zplg-help |-- zplugin-autoload.zsh/-zplg-list-bindkeys |-- zplugin-autoload.zsh/-zplg-list-compdef-replay |-- zplugin-autoload.zsh/-zplg-ls |-- zplugin-autoload.zsh/-zplg-module |-- zplugin-autoload.zsh/-zplg-recently |-- zplugin-autoload.zsh/-zplg-search-completions |-- zplugin-autoload.zsh/-zplg-self-update |-- zplugin-autoload.zsh/-zplg-show-all-reports |-- zplugin-autoload.zsh/-zplg-show-completions |-- zplugin-autoload.zsh/-zplg-show-debug-report |-- zplugin-autoload.zsh/-zplg-show-registered-plugins |-- zplugin-autoload.zsh/-zplg-show-report |-- zplugin-autoload.zsh/-zplg-show-times |-- zplugin-autoload.zsh/-zplg-show-zstatus |-- zplugin-autoload.zsh/-zplg-uncompile-plugin |-- zplugin-autoload.zsh/-zplg-uninstall-completions |-- zplugin-autoload.zsh/-zplg-unload |-- zplugin-autoload.zsh/-zplg-update-or-status |-- zplugin-autoload.zsh/-zplg-update-or-status-all |-- zplugin-install.zsh/-zplg-compile-plugin |-- zplugin-install.zsh/-zplg-forget-completion `-- zplugin-install.zsh/-zplg-install-completions Uses feature(s): autoload , eval , source Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). -zplugin_scheduler_add_sh # Copies task into ZPLG_RUN array, called when a task timeouts. A small function ran from pattern in /-substitution as a math function. Has 7 line(s). Doesn't call other functions. Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). add-zsh-hook # Has 93 line(s). Doesn't call other functions. Uses feature(s): autoload , getopts Called by: Script-Body -zplg-scheduler compinit # Has 549 line(s). Doesn't call other functions. Uses feature(s): autoload , bindkey , eval , read , unfunction , zle , zstyle Called by: zpcompinit zplugin is-at-least # Has 56 line(s). Doesn't call other functions. Called by: Script-Body --zplg-shadow-bindkey","title":"zplugin.zsh"},{"location":"zplugin.zsh/#zpluginzsh1","text":"","title":"zplugin.zsh(1)"},{"location":"zplugin.zsh/#name","text":"zplugin.zsh - a shell script","title":"NAME"},{"location":"zplugin.zsh/#synopsis","text":"Documentation automatically generated with `zshelldoc'","title":"SYNOPSIS"},{"location":"zplugin.zsh/#functions","text":"pmodload zpcdclear zpcdreplay zpcompdef zpcompinit -zplg-add-report -zplg-any-to-user-plugin -zplg-clear-debug-report -zplg-compdef-clear -zplg-compdef-replay -zplg-debug-start -zplg-debug-stop -zplg-debug-unload -zplg-deploy-message -zplg-diff -zplg-diff-env -zplg-diff-functions -zplg-diff-options -zplg-diff-parameter -zplg-find-other-matches -zplg-ice -zplg-load -zplg-load-plugin -zplg-load-snippet -zplg-pack-ice -zplg-prepare-home -zplg-register-plugin @zplg-register-z-plugin --zplg-reload-and-run -zplg-run-task -zplg-service --zplg-shadow-alias --zplg-shadow-autoload --zplg-shadow-bindkey --zplg-shadow-compdef -zplg-shadow-off -zplg-shadow-on --zplg-shadow-zle --zplg-shadow-zstyle -zplg-submit-turbo -zplg-unregister-plugin -zplg-wrap-track-functions zplugin -zplugin_scheduler_add_sh AUTOLOAD add-zsh-hook AUTOLOAD compinit AUTOLOAD is-at-least PRECMD-HOOK -zplg-scheduler","title":"FUNCTIONS"},{"location":"zplugin.zsh/#details","text":"","title":"DETAILS"},{"location":"zplugin.zsh/#script_body","text":"Has 117 line(s). Calls functions: Script-Body |-- add-zsh-hook |-- is-at-least `-- -zplg-prepare-home Uses feature(s): alias , autoload , export , zmodload , zstyle Exports (environment): ZPFX","title":"Script Body"},{"location":"zplugin.zsh/#pmodload","text":"Compatibility with Prezto. Calls can be recursive. Has 9 line(s). Calls functions: pmodload `-- -zplg-load-snippet |-- -zplg-deploy-message |-- -zplg-pack-ice |-- -zplg-wrap-track-functions `-- zplugin-install.zsh/-zplg-download-snippet Uses feature(s): zstyle Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"pmodload"},{"location":"zplugin.zsh/#zpcdclear","text":"A wrapper for `zplugin cdclear -q' which can be called from hook ices like the atinit'', atload'', etc. ices. Has 1 line(s). Calls functions: zpcdclear `-- -zplg-compdef-clear Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"zpcdclear"},{"location":"zplugin.zsh/#zpcdreplay","text":"A function that can be invoked from within `atinit', `atload', etc. ice-mod. It works like `zplugin cdreplay', which cannot be invoked from such hook ices. Has 1 line(s). Calls functions: zpcdreplay `-- -zplg-compdef-replay Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"zpcdreplay"},{"location":"zplugin.zsh/#zpcompdef","text":"Stores compdef for a replay with `zpcdreplay' (turbo mode) or with `zplugin cdreplay' (normal mode). An utility functton of an undefined use case. Has 1 line(s). Doesn't call other functions. Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"zpcompdef"},{"location":"zplugin.zsh/#zpcompinit","text":"A function that can be invoked from within `atinit', `atload', etc. ice-mod. It runs `autoload compinit; compinit' and respects ZPLGM[ZCOMPDUMP_PATH] and ZPLGM[COMPINIT_OPTS]. Has 1 line(s). Calls functions: zpcompinit `-- compinit Uses feature(s): autoload Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"zpcompinit"},{"location":"zplugin.zsh/#-zplg-add-report","text":"Adds a report line for given plugin. $1 - uspl2, i.e. user/plugin $2, ... - the text Has 2 line(s). Doesn't call other functions. Called by: -zplg-load-plugin --zplg-shadow-alias --zplg-shadow-autoload --zplg-shadow-bindkey --zplg-shadow-compdef --zplg-shadow-zle --zplg-shadow-zstyle","title":"-zplg-add-report"},{"location":"zplugin.zsh/#-zplg-any-to-user-plugin","text":"Allows elastic plugin-spec across the code. $1 - plugin spec (2 formats: user/plugin, user plugin) $2 - plugin (only when $1 - i.e. user - given) Returns user and plugin in $reply Has 23 line(s). Doesn't call other functions. Called by: -zplg-load -zplg-unregister-plugin zplugin-autoload.zsh/-zplg-any-to-uspl2 zplugin-autoload.zsh/-zplg-changes zplugin-autoload.zsh/-zplg-compiled zplugin-autoload.zsh/-zplg-compile-uncompile-all zplugin-autoload.zsh/-zplg-compute-ice zplugin-autoload.zsh/-zplg-create zplugin-autoload.zsh/-zplg-delete zplugin-autoload.zsh/-zplg-edit zplugin-autoload.zsh/-zplg-find-completions-of-plugin zplugin-autoload.zsh/-zplg-get-path zplugin-autoload.zsh/-zplg-glance zplugin-autoload.zsh/-zplg-show-report zplugin-autoload.zsh/-zplg-stress zplugin-autoload.zsh/-zplg-uncompile-plugin zplugin-autoload.zsh/-zplg-unload zplugin-autoload.zsh/-zplg-update-or-status-all zplugin-autoload.zsh/-zplg-update-or-status zplugin-install.zsh/-zplg-compile-plugin zplugin-install.zsh/-zplg-get-latest-gh-r-version zplugin-install.zsh/-zplg-install-completions zplugin-side.zsh/-zplg-any-colorify-as-uspl2 zplugin-side.zsh/-zplg-exists-physically zplugin-side.zsh/-zplg-first","title":"-zplg-any-to-user-plugin"},{"location":"zplugin.zsh/#-zplg-clear-debug-report","text":"Forgets dtrace repport gathered up to this moment. Has 1 line(s). Calls functions: -zplg-clear-debug-report `-- zplugin-autoload.zsh/-zplg-clear-report-for Called by: zplugin zplugin-autoload.zsh/-zplg-unload","title":"-zplg-clear-debug-report"},{"location":"zplugin.zsh/#-zplg-compdef-clear","text":"Implements user-exposed functionality to clear gathered compdefs. Has 3 line(s). Doesn't call other functions. Called by: zpcdclear zplugin","title":"-zplg-compdef-clear"},{"location":"zplugin.zsh/#-zplg-compdef-replay","text":"Runs gathered compdef calls. This allows to run `compinit' after loading plugins. Has 16 line(s). Doesn't call other functions. Called by: zpcdreplay zplugin","title":"-zplg-compdef-replay"},{"location":"zplugin.zsh/#-zplg-debug-start","text":"Starts Dtrace, i.e. session tracking for changes in Zsh state. Has 9 line(s). Calls functions: -zplg-debug-start |-- -zplg-diff | |-- -zplg-diff-env | |-- -zplg-diff-functions | |-- -zplg-diff-options | `-- -zplg-diff-parameter `-- -zplg-shadow-on Called by: zplugin","title":"-zplg-debug-start"},{"location":"zplugin.zsh/#-zplg-debug-stop","text":"Stops Dtrace, i.e. session tracking for changes in Zsh state. Has 3 line(s). Calls functions: -zplg-debug-stop |-- -zplg-diff | |-- -zplg-diff-env | |-- -zplg-diff-functions | |-- -zplg-diff-options | `-- -zplg-diff-parameter `-- -zplg-shadow-off Called by: zplugin","title":"-zplg-debug-stop"},{"location":"zplugin.zsh/#-zplg-debug-unload","text":"Reverts changes detected by dtrace run. Has 5 line(s). Calls functions: -zplg-debug-unload `-- zplugin-autoload.zsh/-zplg-unload Called by: zplugin","title":"-zplg-debug-unload"},{"location":"zplugin.zsh/#-zplg-deploy-message","text":"Deploys a sub-prompt message to be displayed OR a `zle .reset-prompt' call to be invoked Has 12 line(s). Doesn't call other functions. Uses feature(s): read , zle Called by: -zplg-load-snippet -zplg-load","title":"-zplg-deploy-message"},{"location":"zplugin.zsh/#-zplg-diff","text":"Performs diff actions of all types Has 4 line(s). Calls functions: -zplg-diff |-- -zplg-diff-env |-- -zplg-diff-functions |-- -zplg-diff-options `-- -zplg-diff-parameter Called by: -zplg-debug-start -zplg-debug-stop -zplg-load-plugin","title":"-zplg-diff"},{"location":"zplugin.zsh/#-zplg-diff-env","text":"Implements detection of change in PATH and FPATH. $1 - user/plugin (i.e. uspl2 format) $2 - command, can be \"begin\" or \"end\" Has 18 line(s). Doesn't call other functions. Called by: -zplg-diff -zplg-load-plugin","title":"-zplg-diff-env"},{"location":"zplugin.zsh/#-zplg-diff-functions","text":"Implements detection of newly created functions. Performs data gathering, computation is done in *-compute(). $1 - user/plugin (i.e. uspl2 format) $2 - command, can be \"begin\" or \"end\" Has 8 line(s). Doesn't call other functions. Called by: -zplg-diff","title":"-zplg-diff-functions"},{"location":"zplugin.zsh/#-zplg-diff-options","text":"Implements detection of change in option state. Performs data gathering, computation is done in *-compute(). $1 - user/plugin (i.e. uspl2 format) $2 - command, can be \"begin\" or \"end\" Has 7 line(s). Doesn't call other functions. Called by: -zplg-diff","title":"-zplg-diff-options"},{"location":"zplugin.zsh/#-zplg-diff-parameter","text":"Implements detection of change in any parameter's existence and type. Performs data gathering, computation is done in *-compute(). $1 - user/plugin (i.e. uspl2 format) $2 - command, can be \"begin\" or \"end\" Has 9 line(s). Doesn't call other functions. Called by: -zplg-diff","title":"-zplg-diff-parameter"},{"location":"zplugin.zsh/#-zplg-find-other-matches","text":"Plugin's main source file is in general `name.plugin.zsh'. However, there can be different conventions, if that file is not found, then this functions examines other conventions in order of most expected sanity. Has 14 line(s). Doesn't call other functions. Called by: -zplg-load-plugin zplugin-side.zsh/-zplg-first","title":"-zplg-find-other-matches"},{"location":"zplugin.zsh/#-zplg-ice","text":"Parses ICE specification (`zplg ice' subcommand), puts the result into ZPLG_ICE global hash. The ice-spec is valid for next command only (i.e. it \"melts\"), but it can then stick to plugin and activate e.g. at update. Has 8 line(s). Doesn't call other functions. Called by: zplugin Environment variables used: ZPFX","title":"-zplg-ice"},{"location":"zplugin.zsh/#-zplg-load","text":"Implements the exposed-to-user action of loading a plugin. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin name, if the third format is used Has 42 line(s). Calls functions: -zplg-load |-- -zplg-any-to-user-plugin |-- -zplg-deploy-message |-- -zplg-load-plugin | |-- -zplg-add-report | |-- -zplg-diff | | |-- -zplg-diff-env | | |-- -zplg-diff-functions | | |-- -zplg-diff-options | | `-- -zplg-diff-parameter | |-- -zplg-diff-env | |-- -zplg-find-other-matches | |-- -zplg-shadow-off | |-- -zplg-shadow-on | `-- -zplg-wrap-track-functions |-- -zplg-pack-ice |-- -zplg-register-plugin `-- zplugin-install.zsh/-zplg-setup-plugin-dir Uses feature(s): eval , source , zle Called by: -zplg-run-task -zplg-service zplugin","title":"-zplg-load"},{"location":"zplugin.zsh/#-zplg-load-plugin","text":"Lower-level function for loading a plugin. $1 - user $2 - plugin $3 - mode (light or load) Has 96 line(s). Calls functions: -zplg-load-plugin |-- -zplg-add-report |-- -zplg-diff | |-- -zplg-diff-env | |-- -zplg-diff-functions | |-- -zplg-diff-options | `-- -zplg-diff-parameter |-- -zplg-diff-env |-- -zplg-find-other-matches |-- -zplg-shadow-off |-- -zplg-shadow-on `-- -zplg-wrap-track-functions Uses feature(s): eval , source , zle Called by: -zplg-load","title":"-zplg-load-plugin"},{"location":"zplugin.zsh/#-zplg-load-snippet","text":"Implements the exposed-to-user action of loading a snippet. $1 - url (can be local, absolute path) Has 180 line(s). Calls functions: -zplg-load-snippet |-- -zplg-deploy-message |-- -zplg-pack-ice |-- -zplg-wrap-track-functions `-- zplugin-install.zsh/-zplg-download-snippet Uses feature(s): autoload , eval , source , unfunction , zparseopts , zstyle Called by: pmodload -zplg-run-task -zplg-service zplugin zplugin-autoload.zsh/-zplg-update-or-status-snippet","title":"-zplg-load-snippet"},{"location":"zplugin.zsh/#-zplg-pack-ice","text":"Remembers all ice-mods, assigns them to concrete plugin. Ice spec is in general forgotten for second-next command (that's why it's called \"ice\" - it melts), however they glue to the object (plugin or snippet) mentioned in the next command \u2013 for later use with e.g. `zplugin update ...' Has 3 line(s). Doesn't call other functions. Called by: -zplg-load-snippet -zplg-load zplugin-autoload.zsh/-zplg-compute-ice","title":"-zplg-pack-ice"},{"location":"zplugin.zsh/#-zplg-prepare-home","text":"Creates all directories needed by Zplugin, first checks if they already exist. Has 28 line(s). Doesn't call other functions. Called by: Script-Body Environment variables used: ZPFX","title":"-zplg-prepare-home"},{"location":"zplugin.zsh/#-zplg-register-plugin","text":"Adds the plugin to ZPLG_REGISTERED_PLUGINS array and to the zsh_loaded_plugins array (managed according to the plugin standard: http://zdharma.org/Zsh-100-Commits-Club/Zsh-Plugin-Standard.html) Has 23 line(s). Doesn't call other functions. Called by: -zplg-load","title":"-zplg-register-plugin"},{"location":"zplugin.zsh/#zplg-register-z-plugin","text":"Registers the z-plugin inside Zplugin \u2013 i.e. an Zplugin extension Has 4 line(s). Doesn't call other functions. Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"@zplg-register-z-plugin"},{"location":"zplugin.zsh/#--zplg-reload-and-run","text":"Marks given function ($3) for autoloading, and executes it triggering the load. $1 is the fpath dedicated to the function, $2 are autoload options. This function replaces \"autoload -X\", because using that on older Zsh versions causes problems with traps. So basically one creates function stub that calls --zplg-reload-and-run() instead of \"autoload -X\". $1 - FPATH dedicated to function $2 - autoload options $3 - function name (one that needs autoloading) Author: Bart Schaefer Has 7 line(s). Doesn't call other functions. Uses feature(s): autoload , unfunction Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"--zplg-reload-and-run"},{"location":"zplugin.zsh/#-zplg-run-task","text":"A backend, worker function of -zplg-scheduler. It obtains the tasks index and a few of its properties (like the type: plugin, snippet, service plugin, service snippet) and executes it first checking for additional conditions (like non-numeric wait'' ice). $1 - the pass number, either 1st or 2nd pass $2 - the time assigned to the task $3 - type: plugin, snippet, service plugin, service snippet $4 - task's index in the ZPLGM[WAIT_ICE_...] fields $5 - mode: load or light $6 - the plugin-spec or snippet URL or alias name (from id-as'') Has 41 line(s). Calls functions: -zplg-run-task |-- -zplg-load | |-- -zplg-any-to-user-plugin | |-- -zplg-deploy-message | |-- -zplg-load-plugin | | |-- -zplg-add-report | | |-- -zplg-diff | | | |-- -zplg-diff-env | | | |-- -zplg-diff-functions | | | |-- -zplg-diff-options | | | `-- -zplg-diff-parameter | | |-- -zplg-diff-env | | |-- -zplg-find-other-matches | | |-- -zplg-shadow-off | | |-- -zplg-shadow-on | | `-- -zplg-wrap-track-functions | |-- -zplg-pack-ice | |-- -zplg-register-plugin | `-- zplugin-install.zsh/-zplg-setup-plugin-dir |-- -zplg-load-snippet | |-- -zplg-deploy-message | |-- -zplg-pack-ice | |-- -zplg-wrap-track-functions | `-- zplugin-install.zsh/-zplg-download-snippet `-- zplugin-autoload.zsh/-zplg-unload Uses feature(s): eval , source , zle , zpty Called by: -zplg-scheduler","title":"-zplg-run-task"},{"location":"zplugin.zsh/#-zplg-scheduler","text":"Searches for timeout tasks, executes them. There's an array of tasks waiting for execution, this scheduler manages them, detects which ones should be run at current moment, decides to remove (or not) them from the array after execution. $1 - if \"following\", then it is non-first (second and more) invocation of the scheduler; this results in chain of `sched' invocations that results in repetitive -zplg-scheduler activity if \"burst\", then all tasks are marked timeout and executed one by one; this is handy if e.g. a docker image starts up and needs to install all turbo-mode plugins without any hesitation (delay), i.e. \"burst\" allows to run package installations from script, not from prompt Has 62 line(s). Is a precmd hook . Calls functions: -zplg-scheduler |-- add-zsh-hook `-- -zplg-run-task |-- -zplg-load | |-- -zplg-any-to-user-plugin | |-- -zplg-deploy-message | |-- -zplg-load-plugin | | |-- -zplg-add-report | | |-- -zplg-diff | | | |-- -zplg-diff-env | | | |-- -zplg-diff-functions | | | |-- -zplg-diff-options | | | `-- -zplg-diff-parameter | | |-- -zplg-diff-env | | |-- -zplg-find-other-matches | | |-- -zplg-shadow-off | | |-- -zplg-shadow-on | | `-- -zplg-wrap-track-functions | |-- -zplg-pack-ice | |-- -zplg-register-plugin | `-- zplugin-install.zsh/-zplg-setup-plugin-dir |-- -zplg-load-snippet | |-- -zplg-deploy-message | |-- -zplg-pack-ice | |-- -zplg-wrap-track-functions | `-- zplugin-install.zsh/-zplg-download-snippet `-- zplugin-autoload.zsh/-zplg-unload Uses feature(s): sched , zle Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"-zplg-scheduler"},{"location":"zplugin.zsh/#-zplg-service","text":"Handles given service, i.e. obtains lock, runs it, or waits if no lock $1 - type \"p\" or \"s\" (plugin or snippet) $2 - mode - for plugin (light or load) $3 - id - URL or plugin ID or alias name (from id-as'') Has 30 line(s). Calls functions: -zplg-service |-- -zplg-load | |-- -zplg-any-to-user-plugin | |-- -zplg-deploy-message | |-- -zplg-load-plugin | | |-- -zplg-add-report | | |-- -zplg-diff | | | |-- -zplg-diff-env | | | |-- -zplg-diff-functions | | | |-- -zplg-diff-options | | | `-- -zplg-diff-parameter | | |-- -zplg-diff-env | | |-- -zplg-find-other-matches | | |-- -zplg-shadow-off | | |-- -zplg-shadow-on | | `-- -zplg-wrap-track-functions | |-- -zplg-pack-ice | |-- -zplg-register-plugin | `-- zplugin-install.zsh/-zplg-setup-plugin-dir `-- -zplg-load-snippet |-- -zplg-deploy-message |-- -zplg-pack-ice |-- -zplg-wrap-track-functions `-- zplugin-install.zsh/-zplg-download-snippet Uses feature(s): kill , read Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"-zplg-service"},{"location":"zplugin.zsh/#--zplg-shadow-alias","text":"Function defined to hijack plugin's calls to `alias' builtin. The hijacking is to gather report data (which is used in unload). Has 34 line(s). Calls functions: --zplg-shadow-alias `-- -zplg-add-report Uses feature(s): alias , zparseopts Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"--zplg-shadow-alias"},{"location":"zplugin.zsh/#--zplg-shadow-autoload","text":"Function defined to hijack plugin's calls to `autoload' builtin. The hijacking is not only to gather report data, but also to run custom `autoload' function, that doesn't need FPATH. Has 48 line(s). Calls functions: --zplg-shadow-autoload `-- -zplg-add-report Uses feature(s): autoload , eval , zparseopts Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"--zplg-shadow-autoload"},{"location":"zplugin.zsh/#--zplg-shadow-bindkey","text":"Function defined to hijack plugin's calls to `bindkey' builtin. The hijacking is to gather report data (which is used in unload). Has 104 line(s). Calls functions: --zplg-shadow-bindkey |-- is-at-least `-- -zplg-add-report Uses feature(s): bindkey , zparseopts Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"--zplg-shadow-bindkey"},{"location":"zplugin.zsh/#--zplg-shadow-compdef","text":"Function defined to hijack plugin's calls to `compdef' function. The hijacking is not only for reporting, but also to save compdef calls so that `compinit' can be called after loading plugins. Has 4 line(s). Calls functions: --zplg-shadow-compdef `-- -zplg-add-report Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"--zplg-shadow-compdef"},{"location":"zplugin.zsh/#-zplg-shadow-off","text":"Turn off shadowing completely for a given mode (\"load\", \"light\", \"light-b\" (i.e. the `trackbinds' mode) or \"compdef\"). Has 18 line(s). Doesn't call other functions. Uses feature(s): unfunction Called by: -zplg-debug-stop -zplg-load-plugin","title":"-zplg-shadow-off"},{"location":"zplugin.zsh/#-zplg-shadow-on","text":"Turn on shadowing of builtins and functions according to passed mode (\"load\", \"light\", \"light-b\" or \"compdef\"). The shadowing is to gather report data, and to hijack `autoload', `bindkey' and `compdef' calls. Has 25 line(s). Doesn't call other functions. Called by: -zplg-debug-start -zplg-load-plugin","title":"-zplg-shadow-on"},{"location":"zplugin.zsh/#--zplg-shadow-zle","text":"Function defined to hijack plugin's calls to `zle' builtin. The hijacking is to gather report data (which is used in unload). Has 38 line(s). Calls functions: --zplg-shadow-zle `-- -zplg-add-report Uses feature(s): zle Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"--zplg-shadow-zle"},{"location":"zplugin.zsh/#--zplg-shadow-zstyle","text":"Function defined to hijack plugin's calls to `zstyle' builtin. The hijacking is to gather report data (which is used in unload). Has 21 line(s). Calls functions: --zplg-shadow-zstyle `-- -zplg-add-report Uses feature(s): zparseopts , zstyle Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"--zplg-shadow-zstyle"},{"location":"zplugin.zsh/#-zplg-submit-turbo","text":"If `zplugin load`, `zplugin light` or `zplugin snippet` will be preceded with `wait', `load', `unload' or `on-update-of`/`subscribe' ice-mods then the plugin or snipped is to be loaded in turbo-mode, and this function adds it to internal data structures, so that -zplg-scheduler can run (load, unload) this as a task. Has 14 line(s). Doesn't call other functions. Called by: zplugin","title":"-zplg-submit-turbo"},{"location":"zplugin.zsh/#-zplg-unregister-plugin","text":"Removes the plugin from ZPLG_REGISTERED_PLUGINS array and from the zsh_loaded_plugins array (managed according to the plugin standard) Has 5 line(s). Calls functions: -zplg-unregister-plugin `-- -zplg-any-to-user-plugin Called by: zplugin-autoload.zsh/-zplg-unload","title":"-zplg-unregister-plugin"},{"location":"zplugin.zsh/#-zplg-wrap-track-functions","text":"Has 19 line(s). Doesn't call other functions. Uses feature(s): eval Called by: -zplg-load-plugin -zplg-load-snippet","title":"-zplg-wrap-track-functions"},{"location":"zplugin.zsh/#zplugin","text":"Main function directly exposed to user, obtains subcommand and its arguments, has completion. Has 290 line(s). Calls functions: zplugin |-- compinit |-- -zplg-clear-debug-report | `-- zplugin-autoload.zsh/-zplg-clear-report-for |-- -zplg-compdef-clear |-- -zplg-compdef-replay |-- -zplg-debug-start | |-- -zplg-diff | | |-- -zplg-diff-env | | |-- -zplg-diff-functions | | |-- -zplg-diff-options | | `-- -zplg-diff-parameter | `-- -zplg-shadow-on |-- -zplg-debug-stop | |-- -zplg-diff | | |-- -zplg-diff-env | | |-- -zplg-diff-functions | | |-- -zplg-diff-options | | `-- -zplg-diff-parameter | `-- -zplg-shadow-off |-- -zplg-debug-unload | `-- zplugin-autoload.zsh/-zplg-unload |-- -zplg-ice |-- -zplg-load | |-- -zplg-any-to-user-plugin | |-- -zplg-deploy-message | |-- -zplg-load-plugin | | |-- -zplg-add-report | | |-- -zplg-diff | | | |-- -zplg-diff-env | | | |-- -zplg-diff-functions | | | |-- -zplg-diff-options | | | `-- -zplg-diff-parameter | | |-- -zplg-diff-env | | |-- -zplg-find-other-matches | | |-- -zplg-shadow-off | | |-- -zplg-shadow-on | | `-- -zplg-wrap-track-functions | |-- -zplg-pack-ice | |-- -zplg-register-plugin | `-- zplugin-install.zsh/-zplg-setup-plugin-dir |-- -zplg-load-snippet | |-- -zplg-deploy-message | |-- -zplg-pack-ice | |-- -zplg-wrap-track-functions | `-- zplugin-install.zsh/-zplg-download-snippet |-- -zplg-submit-turbo |-- zplugin-autoload.zsh/-zplg-cdisable |-- zplugin-autoload.zsh/-zplg-cenable |-- zplugin-autoload.zsh/-zplg-clear-completions |-- zplugin-autoload.zsh/-zplg-compiled |-- zplugin-autoload.zsh/-zplg-compile-uncompile-all |-- zplugin-autoload.zsh/-zplg-compinit |-- zplugin-autoload.zsh/-zplg-help |-- zplugin-autoload.zsh/-zplg-list-bindkeys |-- zplugin-autoload.zsh/-zplg-list-compdef-replay |-- zplugin-autoload.zsh/-zplg-ls |-- zplugin-autoload.zsh/-zplg-module |-- zplugin-autoload.zsh/-zplg-recently |-- zplugin-autoload.zsh/-zplg-search-completions |-- zplugin-autoload.zsh/-zplg-self-update |-- zplugin-autoload.zsh/-zplg-show-all-reports |-- zplugin-autoload.zsh/-zplg-show-completions |-- zplugin-autoload.zsh/-zplg-show-debug-report |-- zplugin-autoload.zsh/-zplg-show-registered-plugins |-- zplugin-autoload.zsh/-zplg-show-report |-- zplugin-autoload.zsh/-zplg-show-times |-- zplugin-autoload.zsh/-zplg-show-zstatus |-- zplugin-autoload.zsh/-zplg-uncompile-plugin |-- zplugin-autoload.zsh/-zplg-uninstall-completions |-- zplugin-autoload.zsh/-zplg-unload |-- zplugin-autoload.zsh/-zplg-update-or-status |-- zplugin-autoload.zsh/-zplg-update-or-status-all |-- zplugin-install.zsh/-zplg-compile-plugin |-- zplugin-install.zsh/-zplg-forget-completion `-- zplugin-install.zsh/-zplg-install-completions Uses feature(s): autoload , eval , source Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"zplugin"},{"location":"zplugin.zsh/#-zplugin_scheduler_add_sh","text":"Copies task into ZPLG_RUN array, called when a task timeouts. A small function ran from pattern in /-substitution as a math function. Has 7 line(s). Doesn't call other functions. Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"-zplugin_scheduler_add_sh"},{"location":"zplugin.zsh/#add-zsh-hook","text":"Has 93 line(s). Doesn't call other functions. Uses feature(s): autoload , getopts Called by: Script-Body -zplg-scheduler","title":"add-zsh-hook"},{"location":"zplugin.zsh/#compinit","text":"Has 549 line(s). Doesn't call other functions. Uses feature(s): autoload , bindkey , eval , read , unfunction , zle , zstyle Called by: zpcompinit zplugin","title":"compinit"},{"location":"zplugin.zsh/#is-at-least","text":"Has 56 line(s). Doesn't call other functions. Called by: Script-Body --zplg-shadow-bindkey","title":"is-at-least"},{"location":"zsh-native-scripting-handbook/","text":"Zsh Native Scripting Handbook # This document has been created after 4 years of creating software for Zshell and receiving help from IRC channel #zsh. Avoiding forks was the main guideline when creating the projects and this lead to multiple discoveries of Zsh constructs that are fast, robust and do not depend on external tools. Such code is more like Ruby or Perl code, less like top-down shell scripts. Information # @ is about keeping array form # How to access all array elements in a shell? The standard answer: use @ subscript , i.e. ${array[@]} . However, this is the Bash & Ksh way (and with the option KSH_ARRAYS , Zsh also works this way, i.e. needs @ to access whole array). Zshell is different : it is $array that refers to all elements anyway. There is no need of @ subscript. So what use has @ in the Zsh-world? It is: \" keep array form \" or \" do not join \". When is it activated? When user quotes the array, i.e. invokes \"$array\" , he induces joining of all array elements (into a single string). @ is to have elements still quoted (so empty elements are preserved), but not joined. Two forms are available, \"$array[@]\" and \"${(@)array}\" . First form has additional effect \u2013 when option KSH_ARRAYS is set, it indeed induces referencing to whole array instead of first element only. It should then use braces, i.e. ${array[@]} , \"${array[@]}\" ( KSH_ARRAYS requirement). In practice, if you'll use @ as a subscript \u2013 [@] , not as a flag \u2013 ${(@)...} , then you'll make the code KSH_ARRAYS -compatible. extended_glob # Glob-flags #b and #m require setopt extended_glob . Patterns utilizing ~ and ^ also require it. Extended-glob is one of the main features of Zsh. Constructs # Reading a file # declare -a lines; lines=( \"${(@f)\"$(<path/file)\"}\" ) This preserves empty lines because of double-quoting (the outside one). @ -flag is used to obtain array instead of scalar. If you don't want empty lines preserved, you can also skip @ -splitting, as it is explained in Information section: declare -a lines; lines=( ${(f)\"$(<path/file)\"} ) Note: $(<...) construct strips trailing empty lines. Reading from stdin # This topic is governed by the same principles a the previous paragraph ( Reading a file ), with the single difference that instead of the substitution \"$(<file-path)\" the substitution that should be used is \"$(command arg1 ...)\" , i.e.: declare -a lines; lines=( ${(f)\"$(command arg1 ...)\"} ) This will read the command's output into the array lines . The version that does @ splitting and retains any empty lines is: declare -a lines; lines=( \"${(f@)$(command arg1 ...)}\" ) Note that instead of four double-quotes \" , an idiom that is justified (simply suggested) by the Zsh documentation (and was used in the previous paragraph, in the snippet ... \"${(@f)\"$(<path/file)\"}\" ... ), only two double-quotes are being used. I've investigated this form with the main Zsh developers on the zsh-workers@zsh.org mailing list, and it was clearly stated that single, outside quoting of ${(f@)...} substitution works as if it was also separately applied to $(command ...) (or to $(<file-path) ) inner substitution, so the second double-quoting isn't actually needed. Skipping grep # declare -a lines; lines=( \"${(@f)\"$(<path/file)\"}\" ) declare -a grepped; grepped=( ${(M)lines:#*query*} ) To have grep -v effect, skip M -flag. To grep case insensitively, use \\#i glob flag ( ...:#(#i)\\*query*} ). As it can be seen, ${...:#...} substitution is a filtering of array, which by default filters-out elements ( (M) flag induces the opposite behavior). When used with string, not an array, it behaves similarily: returns empty string when {input_string_var:#pattern} matches whole input string. Side-note: (M) flag can be used also with ${(M)var#pattern} and other substitutions, to retain what's matched by the pattern instead of removing that. Multi-line matching like with grep # Suppose you have a Subversion repository and want to check if it contains files being not under version control. You could do this in Bash style like follows: local svn_status=\"$(svn status)\" if [[ -n \"$(echo \"$svn_status\" | \\grep \\^\\?)\" ]]; then echo found fi That are 3 forks: for svn status , for echo and for grep . This can be solved by :# substitution and (M) flag described above in this section (just check if the number of matched lines is greater than 0). However, there's a more direct approach: local svn_status=\"$(svn status)\" nl=$'\\n' if [[ \"$svn_status\" = *((#s)|$nl)\\?* ]]; then echo found fi This requires extendedglob . The (#s) means: \"start of the string\". So ((#s)|$nl) means \"start of the string OR preceded by a new-line\". If the extendedglob option cannot be used for some reason, this can be achieved also without it, but essentially it means that alternative (i.e. | ) of two versions of the pattern will have to be matched: setopt localoptions noextendedglob local svn_status=\"$(svn status)\" nl=$'\\n' if [[ \"$svn_status\" = (\\?*|*$nl\\?*) ]]; then echo found fi In general, multi-line matching falls into the following idiom ( extendedglob version): local needle=\"?\" required_preceding='[[:space:]]#' [[ \"$(svn status)\" = *((#s)|$nl)${~required_preceding}${needle}* ]] && echo found It does a single fork (calls svn status ). The ${~variable} means (the ~ in it): \"the variable is holding a pattern, interpret it\". All in all, instead of regular expressions we were using patterns (globs) (see link:#built-in-regular-expressions-engine[this section]). Pattern matching in AND-fashion # [[ \"abc xyz efg\" = *abc*~^*efg* ]] && print Match found The ~ is a negation -- match \\*abc* but not ... . Then, ^ is also a negation. The effect is: \\*abc* but not those that don't have \\*efg* which equals to: \\*abc* but those that have also \\*efg* . This is a regular pattern and it can be used with :# above to search arrays, or with R -subscript flag to search hashes ( ${hsh[\\(R)\\*pattern*]} ), etc. Inventor of those patterns is Mikael Magnusson. Skipping tr # declare -A map; map=( a 1 b 2 ); text=( \"ab\" \"ba\" ) text=( ${text[@]//(#m)?/${map[$MATCH]}} ) print $text \u25b6 12 21 #m flag enables the $MATCH parameter. At each // substitution, $map is queried for character-replacement. You can substitute a text variable too, just skip [@] and parentheses in assignment. Ternary expressions with \\+,-,:+,:- substitutions # HELP=\"yes\"; print ${${HELP:+help enabled}:-help disabled} \u25b6 help enabled HELP=\"\"; print ${${HELP:+help enabled}:-help disabled} \u25b6 help disabled Ternary expression is known from C language but exists also in Zsh, but directly only in math context, i.e. \\(( a = a > 0 ? b : c )) . Flexibility of Zsh allows such expressions also in normal context. Above is an example. :+ is \"if not empty, substitute \u2026\" :- is \"if empty, substitute \u2026\". You can save great number of lines of code with those substitutions, it's normally at least 4-lines if condition or lenghty && / || use. Ternary expressions with :# substitution # var=abc; print ${${${(M)var:#abc}:+is abc}:-not abc} \u25b6 is abc var=abcd; print ${${${(M)var:#abc}:+is abc}:-not abc} \u25b6 not abc An one-line \"if var = x, then \u2026, else \u2026\". Again, can spare a great amount of boring code that makes 10-line function a 20-line one. Using built-in regular expressions engine # [[ \"aabbb\" = (#b)(a##)*(b(#c2,2)) ]] && print ${match[1]}-${match[2]} \u25b6 aa-bb \\## is: \"1 or more\". (#c2,2) is: \"exactly 2\". A few other constructs: # is \"0 or more\", ? is \"any character\", (a|b|) is \"a or b or empty match\". #b enables the $match parameters. There's also #m but it has one parameter $MATCH for whole matched text, not for any parenthesis. Zsh patterns are basically a custom regular expressions engine. They are slightly faster than zsh/regex module (used for =~ operator) and don't have that dependency (regex module can be not present, e.g. in default static build of Zsh). Also, they can be used in substitutions, for example in // substitution. Skipping uniq # declare -aU array; array=( a a b ); print $array \u25b6 a b declare -a array; array=( a a b ); print ${(u)array} \u25b6 a b Enable -U flag for array so that it guards elements to be unique, or use u -flag to uniquify elements of any array. Skipping awk # declare -a list; list=( \"a,b,c,1,e\" \"p,q,r,2,t\" ); print \"${list[@]/(#b)([^,]##,)(#c3,3)([^,]##)*/${match[2]}}\" \u25b6 1 2 The pattern specifies 3 blocks of [^,]##, so 3 \"not-comma multiple times, then comma\", then single block of \"not-comma multiple times\" in second parentheses -- and then replaces this with second parentheses. Result is 4 th column extracted from multiple lines of text, something awk is often used for. Other method is use of s -flag. For single line of text: text=\"a,b,c,1,e\"; print ${${(s:,:)text}[4]} \u25b6 1 Thanks to in-substitution code-execution capabilities it's possible to use s -flag to apply it to multiple lines: declare -a list; list=( \"a,b,c,1,e\" \"p,q,r,2,t\" ); print \"${list[@]/(#m)*/${${(s:,:)MATCH}[4]}}\" \u25b6 1 2 There is a problem with the (s::) flag that can be solved if Zsh is version 5.4 or higher: if there will be single input column, e.g. list=( \"column1\" \"a,b\") instead of two or more columns (i.e. list=( \"column1,column2\" \"a,b\" ) ), then (s::) will return string instead of 1-element array . So the index [4] in above snippet will index a string, and show its 4-th letter. Starting with Zsh 5.4, thanks to a patch by Bart Schaefer ( 40640: the (A) parameter flag forces array result even if... ), it is possible to force array -kind of result even for single column, by adding (A) flag, i.e.: declare -a list; list=( \"a,b,c,1,e\" \"p,q,r,2,t\" \"column1\" ); print \"${list[@]/(#m)*/${${(As:,:)MATCH}[4]}}\" \u25b6 1 2 print \"${list[@]/(#m)*/${${(s:,:)MATCH}[4]}}\" \u25b6 1 2 u Side-note: (A) flag is often used together with ::= assignment-substitution and (P) flag, to assign arrays and hashes by-name. Searching arrays # declare -a array; array=( a b \" c1\" d ); print ${array[(r)[[:space:]][[:alpha:]]*]} \u25b6 c1 \\[[:space:]] contains unicode spaces. This is often used in conditional expression like [[ -z ${array[(r)...]} ]] . Note that link:#skipping-grep[Skipping grep] that uses :# substitution can also be used to search arrays. Code execution in // substitution # append() { gathered+=( $array[$1] ); } functions -M append 1 1 append declare -a array; array=( \"Value 1\" \"Other data\" \"Value 2\" ) declare -a gathered; integer idx=0 : ${array[@]/(#b)(Value ([[:digit:]]##)|*)/$(( ${#match[2]} > 0 ? append(++idx) : ++idx ))} print $gathered \u25b6 Value 1 Value 2 Use of #b glob flag enables math-code execution (and not only) in / and // substitutions. Implementation is very fast. Serializing data # declare -A hsh deserialized; hsh=( key value ) serialized=\"${(j: :)${(qkv@)hsh}}\" deserialized=( \"${(Q@)${(z@)serialized}}\" ) print ${(kv)deserialized} \u25b6 key value j -flag means join -- by spaces, in this case. Flags kv mean: keys and values, interleaving. Important q -flag means: quote. So what is obtained is each key and value quoted, and put into string separated by spaces. z -flag means: split as if Zsh parser would split. So quoting (with backslashes, double quoting and other) is recognized. Obtained is array ( \"key\" \"value\") which is then dequoted with Q -flag. This yields original data, assigned to hash deserialized . Use this to e.g. implement array of hashes. Note: to be compatible with setopt ksharrays , use [@] instead of (@) , e.g.: ...( \"${(Q)${(z)serialized[@]}[@]}\" ) Tip: serializing with Bash # array=( key1 key2 ) printf -v serialized \"%q \" \"${array[@]}\" eval \"deserialized=($serialized)\" This method works also with Zsh. The drawback is use of eval , however it's impossible that any problem will occurr unless someone compromises variable's value, but as always, eval should be avoided if possible. Real world examples # Testing for Git subcommand # Following code checks if there is a git subcommand $mysub : if git help -a | grep \"^ [a-z]\" | tr ' ' '\\n' | grep -x $mysub > /dev/null > /dev/null; then That are 4 forks. The code can be replaced according to this guide: local -a lines_list lines_list=( ${(f)\"$(git help -a)\"} ) lines_list=( ${(M)${(s: :)${(M)lines_list:# [a-z]*}}:#$mysub} ) if (( ${#lines_list} > 0 )); then The result is just 1 fork. Counting unquoted-only apostrophes # A project was needing this to do some Zle line-continuation tricks (when you put a backslash-\\ at the end of the line and press enter \u2013 it is the line-continuation that occurs at that moment). The required functionality is: in given string, count the number of apostrophes, but only the unquoted ones . This means that only apostrophes with null or an even number of preceding backslashes should be accepted into the count: buf=\"word'continue\\'after\\\\\\'afterSecnd\\\\''afterPair\" integer count=0 : ${buf//(#b)((#s)|[^\\\\])([\\\\][\\\\])#(\\'\\'#)/$(( count += ${#match[3]} ))} echo $count \u25b6 3 The answer (i.e. the output) to the above presentation and example is: 3 (there are 3 unquoted apostrophes in total in the string kept in the variable $buf ). Below follows a variation of above snippet that doesn't use math-code execution: buf=\"word'continue\\'after\\\\\\'afterSecnd\\\\''afterPair\" buf=\"${(S)buf//(#b)*((#s)|[^\\\\])([\\\\][\\\\])#(\\'\\'#)*/${match[3]}}\"; buf=${buf%%[^\\']##} integer count=${#buf} echo $count \u25b6 3 This is possible thanks to (S) flag \u2013 non-greedy matching, ([\\\\][\\\\])# trick \u2013 it matches only unquoted following (\\'\\'##) characters (which are the apostrophes) and a general strategy to replace anything-apostrope(s) (unquoted ones) with the-apostrope(s) (and then count them with ${#buf} ). Tips and Tricks # Parsing INI file # With Zshell's extended_glob parsing an ini file is an easy task. It will not result in a nested-arrays data structure (Zsh doesn't support nested hashes), but the hash keys like $DB_CONF[db1_<connection>_host] are actually really intuitive. The code should be placed in file named read-ini-file , in $fpath , and autoload read-ini-file should be invoked. # Copyright (c) 2018 Sebastian Gniazdowski # # $1 - path to the ini file to parse # $2 - name of output hash # $3 - prefix for keys in the hash # # Writes to given hash under keys built in following way: ${3}<section>_field. # Values are values from ini file. Example invocation: # # read-ini-file ./database1-setup.ini DB_CONF db1_ # read-ini-file ./database2-setup.ini DB_CONF db2_ # setopt localoptions extendedglob local __ini_file=\"$1\" __out_hash=\"$2\" __key_prefix=\"$3\" local IFS='' __line __cur_section=\"void\" __access_string local -a match mbegin mend [[ ! -r \"$__ini_file\" ]] && { builtin print -r \"read-ini-file: an ini file is unreadable ($__ini_file)\"; return 1; } while read -r -t 1 __line; do if [[ \"$__line\" = [[:blank:]]#\\;* ]]; then continue # Match \"[Section]\" line elif [[ \"$__line\" = (#b)[[:blank:]]#\\[([^\\]]##)\\][[:blank:]]# ]]; then __cur_section=\"${match[1]}\" # Match \"string = string\" line elif [[ \"$__line\" = (#b)[[:blank:]]#([^[:blank:]=]##)[[:blank:]]#[=][[:blank:]]#(*) ]]; then match[2]=\"${match[2]%\"${match[2]##*[! $'\\t']}\"}\" # severe trick - remove trailing whitespace __access_string=\"${__out_hash}[${__key_prefix}<$__cur_section>_${match[1]}]\" : \"${(P)__access_string::=${match[2]}}\" fi done < \"$__ini_file\" return 0","title":"Zsh Native Scripting Handbook"},{"location":"zsh-native-scripting-handbook/#zsh_native_scripting_handbook","text":"This document has been created after 4 years of creating software for Zshell and receiving help from IRC channel #zsh. Avoiding forks was the main guideline when creating the projects and this lead to multiple discoveries of Zsh constructs that are fast, robust and do not depend on external tools. Such code is more like Ruby or Perl code, less like top-down shell scripts.","title":"Zsh Native Scripting Handbook"},{"location":"zsh-native-scripting-handbook/#information","text":"","title":"Information"},{"location":"zsh-native-scripting-handbook/#is_about_keeping_array_form","text":"How to access all array elements in a shell? The standard answer: use @ subscript , i.e. ${array[@]} . However, this is the Bash & Ksh way (and with the option KSH_ARRAYS , Zsh also works this way, i.e. needs @ to access whole array). Zshell is different : it is $array that refers to all elements anyway. There is no need of @ subscript. So what use has @ in the Zsh-world? It is: \" keep array form \" or \" do not join \". When is it activated? When user quotes the array, i.e. invokes \"$array\" , he induces joining of all array elements (into a single string). @ is to have elements still quoted (so empty elements are preserved), but not joined. Two forms are available, \"$array[@]\" and \"${(@)array}\" . First form has additional effect \u2013 when option KSH_ARRAYS is set, it indeed induces referencing to whole array instead of first element only. It should then use braces, i.e. ${array[@]} , \"${array[@]}\" ( KSH_ARRAYS requirement). In practice, if you'll use @ as a subscript \u2013 [@] , not as a flag \u2013 ${(@)...} , then you'll make the code KSH_ARRAYS -compatible.","title":"@ is about keeping array form"},{"location":"zsh-native-scripting-handbook/#extended_glob","text":"Glob-flags #b and #m require setopt extended_glob . Patterns utilizing ~ and ^ also require it. Extended-glob is one of the main features of Zsh.","title":"extended_glob"},{"location":"zsh-native-scripting-handbook/#constructs","text":"","title":"Constructs"},{"location":"zsh-native-scripting-handbook/#reading_a_file","text":"declare -a lines; lines=( \"${(@f)\"$(<path/file)\"}\" ) This preserves empty lines because of double-quoting (the outside one). @ -flag is used to obtain array instead of scalar. If you don't want empty lines preserved, you can also skip @ -splitting, as it is explained in Information section: declare -a lines; lines=( ${(f)\"$(<path/file)\"} ) Note: $(<...) construct strips trailing empty lines.","title":"Reading a file"},{"location":"zsh-native-scripting-handbook/#reading_from_stdin","text":"This topic is governed by the same principles a the previous paragraph ( Reading a file ), with the single difference that instead of the substitution \"$(<file-path)\" the substitution that should be used is \"$(command arg1 ...)\" , i.e.: declare -a lines; lines=( ${(f)\"$(command arg1 ...)\"} ) This will read the command's output into the array lines . The version that does @ splitting and retains any empty lines is: declare -a lines; lines=( \"${(f@)$(command arg1 ...)}\" ) Note that instead of four double-quotes \" , an idiom that is justified (simply suggested) by the Zsh documentation (and was used in the previous paragraph, in the snippet ... \"${(@f)\"$(<path/file)\"}\" ... ), only two double-quotes are being used. I've investigated this form with the main Zsh developers on the zsh-workers@zsh.org mailing list, and it was clearly stated that single, outside quoting of ${(f@)...} substitution works as if it was also separately applied to $(command ...) (or to $(<file-path) ) inner substitution, so the second double-quoting isn't actually needed.","title":"Reading from stdin"},{"location":"zsh-native-scripting-handbook/#skipping_grep","text":"declare -a lines; lines=( \"${(@f)\"$(<path/file)\"}\" ) declare -a grepped; grepped=( ${(M)lines:#*query*} ) To have grep -v effect, skip M -flag. To grep case insensitively, use \\#i glob flag ( ...:#(#i)\\*query*} ). As it can be seen, ${...:#...} substitution is a filtering of array, which by default filters-out elements ( (M) flag induces the opposite behavior). When used with string, not an array, it behaves similarily: returns empty string when {input_string_var:#pattern} matches whole input string. Side-note: (M) flag can be used also with ${(M)var#pattern} and other substitutions, to retain what's matched by the pattern instead of removing that.","title":"Skipping grep"},{"location":"zsh-native-scripting-handbook/#multi-line_matching_like_with_grep","text":"Suppose you have a Subversion repository and want to check if it contains files being not under version control. You could do this in Bash style like follows: local svn_status=\"$(svn status)\" if [[ -n \"$(echo \"$svn_status\" | \\grep \\^\\?)\" ]]; then echo found fi That are 3 forks: for svn status , for echo and for grep . This can be solved by :# substitution and (M) flag described above in this section (just check if the number of matched lines is greater than 0). However, there's a more direct approach: local svn_status=\"$(svn status)\" nl=$'\\n' if [[ \"$svn_status\" = *((#s)|$nl)\\?* ]]; then echo found fi This requires extendedglob . The (#s) means: \"start of the string\". So ((#s)|$nl) means \"start of the string OR preceded by a new-line\". If the extendedglob option cannot be used for some reason, this can be achieved also without it, but essentially it means that alternative (i.e. | ) of two versions of the pattern will have to be matched: setopt localoptions noextendedglob local svn_status=\"$(svn status)\" nl=$'\\n' if [[ \"$svn_status\" = (\\?*|*$nl\\?*) ]]; then echo found fi In general, multi-line matching falls into the following idiom ( extendedglob version): local needle=\"?\" required_preceding='[[:space:]]#' [[ \"$(svn status)\" = *((#s)|$nl)${~required_preceding}${needle}* ]] && echo found It does a single fork (calls svn status ). The ${~variable} means (the ~ in it): \"the variable is holding a pattern, interpret it\". All in all, instead of regular expressions we were using patterns (globs) (see link:#built-in-regular-expressions-engine[this section]).","title":"Multi-line matching like with grep"},{"location":"zsh-native-scripting-handbook/#pattern_matching_in_and-fashion","text":"[[ \"abc xyz efg\" = *abc*~^*efg* ]] && print Match found The ~ is a negation -- match \\*abc* but not ... . Then, ^ is also a negation. The effect is: \\*abc* but not those that don't have \\*efg* which equals to: \\*abc* but those that have also \\*efg* . This is a regular pattern and it can be used with :# above to search arrays, or with R -subscript flag to search hashes ( ${hsh[\\(R)\\*pattern*]} ), etc. Inventor of those patterns is Mikael Magnusson.","title":"Pattern matching in AND-fashion"},{"location":"zsh-native-scripting-handbook/#skipping_tr","text":"declare -A map; map=( a 1 b 2 ); text=( \"ab\" \"ba\" ) text=( ${text[@]//(#m)?/${map[$MATCH]}} ) print $text \u25b6 12 21 #m flag enables the $MATCH parameter. At each // substitution, $map is queried for character-replacement. You can substitute a text variable too, just skip [@] and parentheses in assignment.","title":"Skipping tr"},{"location":"zsh-native-scripting-handbook/#ternary_expressions_with_--_substitutions","text":"HELP=\"yes\"; print ${${HELP:+help enabled}:-help disabled} \u25b6 help enabled HELP=\"\"; print ${${HELP:+help enabled}:-help disabled} \u25b6 help disabled Ternary expression is known from C language but exists also in Zsh, but directly only in math context, i.e. \\(( a = a > 0 ? b : c )) . Flexibility of Zsh allows such expressions also in normal context. Above is an example. :+ is \"if not empty, substitute \u2026\" :- is \"if empty, substitute \u2026\". You can save great number of lines of code with those substitutions, it's normally at least 4-lines if condition or lenghty && / || use.","title":"Ternary expressions with \\+,-,:+,:- substitutions"},{"location":"zsh-native-scripting-handbook/#ternary_expressions_with_substitution","text":"var=abc; print ${${${(M)var:#abc}:+is abc}:-not abc} \u25b6 is abc var=abcd; print ${${${(M)var:#abc}:+is abc}:-not abc} \u25b6 not abc An one-line \"if var = x, then \u2026, else \u2026\". Again, can spare a great amount of boring code that makes 10-line function a 20-line one.","title":"Ternary expressions with :# substitution"},{"location":"zsh-native-scripting-handbook/#using_built-in_regular_expressions_engine","text":"[[ \"aabbb\" = (#b)(a##)*(b(#c2,2)) ]] && print ${match[1]}-${match[2]} \u25b6 aa-bb \\## is: \"1 or more\". (#c2,2) is: \"exactly 2\". A few other constructs: # is \"0 or more\", ? is \"any character\", (a|b|) is \"a or b or empty match\". #b enables the $match parameters. There's also #m but it has one parameter $MATCH for whole matched text, not for any parenthesis. Zsh patterns are basically a custom regular expressions engine. They are slightly faster than zsh/regex module (used for =~ operator) and don't have that dependency (regex module can be not present, e.g. in default static build of Zsh). Also, they can be used in substitutions, for example in // substitution.","title":"Using built-in regular expressions engine"},{"location":"zsh-native-scripting-handbook/#skipping_uniq","text":"declare -aU array; array=( a a b ); print $array \u25b6 a b declare -a array; array=( a a b ); print ${(u)array} \u25b6 a b Enable -U flag for array so that it guards elements to be unique, or use u -flag to uniquify elements of any array.","title":"Skipping uniq"},{"location":"zsh-native-scripting-handbook/#skipping_awk","text":"declare -a list; list=( \"a,b,c,1,e\" \"p,q,r,2,t\" ); print \"${list[@]/(#b)([^,]##,)(#c3,3)([^,]##)*/${match[2]}}\" \u25b6 1 2 The pattern specifies 3 blocks of [^,]##, so 3 \"not-comma multiple times, then comma\", then single block of \"not-comma multiple times\" in second parentheses -- and then replaces this with second parentheses. Result is 4 th column extracted from multiple lines of text, something awk is often used for. Other method is use of s -flag. For single line of text: text=\"a,b,c,1,e\"; print ${${(s:,:)text}[4]} \u25b6 1 Thanks to in-substitution code-execution capabilities it's possible to use s -flag to apply it to multiple lines: declare -a list; list=( \"a,b,c,1,e\" \"p,q,r,2,t\" ); print \"${list[@]/(#m)*/${${(s:,:)MATCH}[4]}}\" \u25b6 1 2 There is a problem with the (s::) flag that can be solved if Zsh is version 5.4 or higher: if there will be single input column, e.g. list=( \"column1\" \"a,b\") instead of two or more columns (i.e. list=( \"column1,column2\" \"a,b\" ) ), then (s::) will return string instead of 1-element array . So the index [4] in above snippet will index a string, and show its 4-th letter. Starting with Zsh 5.4, thanks to a patch by Bart Schaefer ( 40640: the (A) parameter flag forces array result even if... ), it is possible to force array -kind of result even for single column, by adding (A) flag, i.e.: declare -a list; list=( \"a,b,c,1,e\" \"p,q,r,2,t\" \"column1\" ); print \"${list[@]/(#m)*/${${(As:,:)MATCH}[4]}}\" \u25b6 1 2 print \"${list[@]/(#m)*/${${(s:,:)MATCH}[4]}}\" \u25b6 1 2 u Side-note: (A) flag is often used together with ::= assignment-substitution and (P) flag, to assign arrays and hashes by-name.","title":"Skipping awk"},{"location":"zsh-native-scripting-handbook/#searching_arrays","text":"declare -a array; array=( a b \" c1\" d ); print ${array[(r)[[:space:]][[:alpha:]]*]} \u25b6 c1 \\[[:space:]] contains unicode spaces. This is often used in conditional expression like [[ -z ${array[(r)...]} ]] . Note that link:#skipping-grep[Skipping grep] that uses :# substitution can also be used to search arrays.","title":"Searching arrays"},{"location":"zsh-native-scripting-handbook/#code_execution_in_substitution","text":"append() { gathered+=( $array[$1] ); } functions -M append 1 1 append declare -a array; array=( \"Value 1\" \"Other data\" \"Value 2\" ) declare -a gathered; integer idx=0 : ${array[@]/(#b)(Value ([[:digit:]]##)|*)/$(( ${#match[2]} > 0 ? append(++idx) : ++idx ))} print $gathered \u25b6 Value 1 Value 2 Use of #b glob flag enables math-code execution (and not only) in / and // substitutions. Implementation is very fast.","title":"Code execution in // substitution"},{"location":"zsh-native-scripting-handbook/#serializing_data","text":"declare -A hsh deserialized; hsh=( key value ) serialized=\"${(j: :)${(qkv@)hsh}}\" deserialized=( \"${(Q@)${(z@)serialized}}\" ) print ${(kv)deserialized} \u25b6 key value j -flag means join -- by spaces, in this case. Flags kv mean: keys and values, interleaving. Important q -flag means: quote. So what is obtained is each key and value quoted, and put into string separated by spaces. z -flag means: split as if Zsh parser would split. So quoting (with backslashes, double quoting and other) is recognized. Obtained is array ( \"key\" \"value\") which is then dequoted with Q -flag. This yields original data, assigned to hash deserialized . Use this to e.g. implement array of hashes. Note: to be compatible with setopt ksharrays , use [@] instead of (@) , e.g.: ...( \"${(Q)${(z)serialized[@]}[@]}\" )","title":"Serializing data"},{"location":"zsh-native-scripting-handbook/#tip_serializing_with_bash","text":"array=( key1 key2 ) printf -v serialized \"%q \" \"${array[@]}\" eval \"deserialized=($serialized)\" This method works also with Zsh. The drawback is use of eval , however it's impossible that any problem will occurr unless someone compromises variable's value, but as always, eval should be avoided if possible.","title":"Tip: serializing with Bash"},{"location":"zsh-native-scripting-handbook/#real_world_examples","text":"","title":"Real world examples"},{"location":"zsh-native-scripting-handbook/#testing_for_git_subcommand","text":"Following code checks if there is a git subcommand $mysub : if git help -a | grep \"^ [a-z]\" | tr ' ' '\\n' | grep -x $mysub > /dev/null > /dev/null; then That are 4 forks. The code can be replaced according to this guide: local -a lines_list lines_list=( ${(f)\"$(git help -a)\"} ) lines_list=( ${(M)${(s: :)${(M)lines_list:# [a-z]*}}:#$mysub} ) if (( ${#lines_list} > 0 )); then The result is just 1 fork.","title":"Testing for Git subcommand"},{"location":"zsh-native-scripting-handbook/#counting_unquoted-only_apostrophes","text":"A project was needing this to do some Zle line-continuation tricks (when you put a backslash-\\ at the end of the line and press enter \u2013 it is the line-continuation that occurs at that moment). The required functionality is: in given string, count the number of apostrophes, but only the unquoted ones . This means that only apostrophes with null or an even number of preceding backslashes should be accepted into the count: buf=\"word'continue\\'after\\\\\\'afterSecnd\\\\''afterPair\" integer count=0 : ${buf//(#b)((#s)|[^\\\\])([\\\\][\\\\])#(\\'\\'#)/$(( count += ${#match[3]} ))} echo $count \u25b6 3 The answer (i.e. the output) to the above presentation and example is: 3 (there are 3 unquoted apostrophes in total in the string kept in the variable $buf ). Below follows a variation of above snippet that doesn't use math-code execution: buf=\"word'continue\\'after\\\\\\'afterSecnd\\\\''afterPair\" buf=\"${(S)buf//(#b)*((#s)|[^\\\\])([\\\\][\\\\])#(\\'\\'#)*/${match[3]}}\"; buf=${buf%%[^\\']##} integer count=${#buf} echo $count \u25b6 3 This is possible thanks to (S) flag \u2013 non-greedy matching, ([\\\\][\\\\])# trick \u2013 it matches only unquoted following (\\'\\'##) characters (which are the apostrophes) and a general strategy to replace anything-apostrope(s) (unquoted ones) with the-apostrope(s) (and then count them with ${#buf} ).","title":"Counting unquoted-only apostrophes"},{"location":"zsh-native-scripting-handbook/#tips_and_tricks","text":"","title":"Tips and Tricks"},{"location":"zsh-native-scripting-handbook/#parsing_ini_file","text":"With Zshell's extended_glob parsing an ini file is an easy task. It will not result in a nested-arrays data structure (Zsh doesn't support nested hashes), but the hash keys like $DB_CONF[db1_<connection>_host] are actually really intuitive. The code should be placed in file named read-ini-file , in $fpath , and autoload read-ini-file should be invoked. # Copyright (c) 2018 Sebastian Gniazdowski # # $1 - path to the ini file to parse # $2 - name of output hash # $3 - prefix for keys in the hash # # Writes to given hash under keys built in following way: ${3}<section>_field. # Values are values from ini file. Example invocation: # # read-ini-file ./database1-setup.ini DB_CONF db1_ # read-ini-file ./database2-setup.ini DB_CONF db2_ # setopt localoptions extendedglob local __ini_file=\"$1\" __out_hash=\"$2\" __key_prefix=\"$3\" local IFS='' __line __cur_section=\"void\" __access_string local -a match mbegin mend [[ ! -r \"$__ini_file\" ]] && { builtin print -r \"read-ini-file: an ini file is unreadable ($__ini_file)\"; return 1; } while read -r -t 1 __line; do if [[ \"$__line\" = [[:blank:]]#\\;* ]]; then continue # Match \"[Section]\" line elif [[ \"$__line\" = (#b)[[:blank:]]#\\[([^\\]]##)\\][[:blank:]]# ]]; then __cur_section=\"${match[1]}\" # Match \"string = string\" line elif [[ \"$__line\" = (#b)[[:blank:]]#([^[:blank:]=]##)[[:blank:]]#[=][[:blank:]]#(*) ]]; then match[2]=\"${match[2]%\"${match[2]##*[! $'\\t']}\"}\" # severe trick - remove trailing whitespace __access_string=\"${__out_hash}[${__key_prefix}<$__cur_section>_${match[1]}]\" : \"${(P)__access_string::=${match[2]}}\" fi done < \"$__ini_file\" return 0","title":"Parsing INI file"},{"location":"zsh-plugin-standard/","text":"Zsh Plugin Standard # This document defines the Zsh Plugin Standard. Zplugin fully supports this standard. This document is also available as a PDF . What is a Zsh plugin? # Historically, Zsh plugins were first defined by Oh My Zsh. They provide for a way to package together files that extend or configure the shell\u2019s functionality in a particular way. At a simple level, a plugin: Has its directory added to $fpath ( Zsh documentation ). Has its first *.plugin.zsh file sourced (or *.zsh , init.zsh , *.sh , these are non-standard). The first point allows plugins to provide completions and functions that are loaded via Zsh\u2019s autoload mechanism (a single function per-file). From a more broad perspective, a plugin consists of: A directory containing various files (main script, autoload functions, completions, Makefiles, backend programs, documentation). A sourcable script that obtains the path to its directory via $0 (see the next section for a related enhancement proposal). A Github (or other site) repository identified by two components username / pluginname . A software package containing any type of command line artifacts \u2013 when used with advanced plugin managers that have hooks, can run Makefiles, add directories to $PATH . Below follow proposed enhancements and codifications of the definition of a \"Zsh plugin\" and the actions of plugin managers \u2013 the proposed standardization. 1. Standardized $0 Handling # To get the plugin\u2019s location, plugins should do: 0=\"${${ZERO:-${0:#$ZSH_ARGZERO}}:-${(%):-%N}}\" 0=\"${${(M)0:#/*}:-$PWD/$0}\" # Then ${0:h} to get plugin\u2019s directory The one-line code above will: Be backwards-compatible with normal $0 setting and usage. Use ZERO if it\u2019s not empty, the plugin manager will be easily able to alter effective $0 before loading a plugin, this allows for e.g. eval \"$(<plugin)\" , which can be faster than source ( comparison , note that it\u2019s not for a compiled script). Use $0 if it doesn\u2019t contain the path to the Zsh binary, plugin manager will still be able to set $0 , although more difficultly (requires unsetopt function_argzero before sourcing plugin script, and 0=\u2026\u200b assignment), unsetopt function_argzero will be detected (it causes $0 not to contain plugin-script path, but path to Zsh binary, if not overwritten by a 0=\u2026\u200b assignment), setopt posix_argzero will be detected (as above). Use %N prompt expansion flag, which always gives absolute path to script, plugin manager cannot alter this (no advanced loading of plugin is possible), but simple plugin-file sourcing (without a plugin manager) will be saved from breaking caused by the mentioned *_argzero options, so this is a very good last-resort fallback. Finally, in the second line, it will ensure that $0 contains an absolute path by prepending it with $PWD if necessary. The goal is flexibility, with essential motivation to support eval \"$(<plugin)\" and definitely solve setopt no_function_argzero and setopt posix_argzero cases. A plugin manager will be even able to convert a plugin to a function (author implemented such proof of concept functionality, it\u2019s fully possible \u2013 also in an automatic fashion), but performance differences of this are yet unclear. It might however provide a use case. The last, 5 th point also allows to use the $0 handling in scripts (i.e. runnables with the hashbang #!\u2026 ) to get the directory in which the script file resides. 2. Unload Function # If a plugin is named e.g. kalc (and is available via an-user/kalc plugin-ID), then it can provide a function, kalc_plugin_unload , that can be called by a plugin manager to undo the effects of loading that plugin. A plugin manager can implement its own tracking of changes made by a plugin so this is in general optional. However, to properly unload e.g. a prompt, dedicated tracking (easy to do for the plugin creator) can provide better, predictable results. Any special, uncommon effects of loading a plugin are possible to undo only by a dedicated function. However, an interesting compromise approach is available \u2013 to withdraw only the special effects of loading a plugin via the dedicated, plugin-provided function and leave the rest to the plugin manager. The value of such approach is that maintaining of such function (if it is to withdraw all plugin side-effects) can be a daunting task requiring constant monitoring of it during the plugin develoment process. 3. Plugin Manager Activity Indicator # Plugin managers should set the $zsh_loaded_plugins array to contain all previously loaded plugins and the plugin currently being loaded (as the last element). This will allow any plugin to: Check which plugins are already loaded. Check if it is being loaded by a plugin manager (i.e. not just sourced). The first item allows a plugin to e.g. issue a notice about missing dependencies. Instead of issuing a notice, it may be able to satisfy the dependencies from resources it provides. For example, pure prompt provides zsh-async dependency library within its source tree, which is normally a separate project. Consequently, the prompt can decide to source its private copy of zsh-async , having also reliable $0 defined by previous section (note: pure doesn\u2019t normally do this). The second item allows a plugin to e.g. set up $fpath , knowing that plugin manager will not handle this: if [[ (${+zsh_loaded_plugins} = 0 || ${zsh_loaded_plugins[-1]} != */kalc) \\ && -z ${fpath[(r)${0:h}]} ]] then fpath+=( \"${0:h}\" ) fi This will allow user to reliably source the plugin without using a plugin manager. 4. Global Parameter With PREFIX For Make, Configure, Etc. # Plugin managers may export the parameter $ZPFX which should contain a path to a directory dedicated for user-land software, i.e. for directories $ZPFX/bin , $ZPFX/lib , $ZPFX/share , etc. Suggested name of the directory is polaris , Zplugin uses this name and places this directory at ~/.zplugin/polaris by default. User can then configure hooks (feature of e.g. zplug and Zplugin) to invoke e.g. make PREFIX=$ZPFX install at clone & update of the plugin to install software like e.g. tj/git-extras . This is a developing role of Zsh plugin managers as package managers, where .zshrc has a similar role to Chef or Puppet configuration and allows to declare system state, and have the same state on different accounts / machines. No-narration facts-list related to $ZPFX : export ZPFX=\"$HOME/polaris\" (or e.g. $HOME/.zplugin/polaris ) make PREFIX=$ZPFX install ./configure --prefix=$ZPFX cmake -DCMAKE_INSTALL_PREFIX=$ZPFX . zplugin ice make\"PREFIX=$ZPFX install\" zplug \u2026 hook-build:\"make PREFIX=$PFX install\" Zsh Plugin-Programming Best Practices # The document is to define a Zsh-plugin but also to serve as an information source for plugin creators. Therefore, it covers also a best practices information in this section. Use Of add-zsh-hook To Install Hooks # Zsh ships with a function add-zsh-hook . It has the following invocation syntax: add-zsh-hook [ -L | -dD ] [ -Uzk ] hook function The command installs a function as one of the supported zsh hook entries. which are one of: chpwd , periodic , precmd , preexec , zshaddhistory , zshexit , zsh_directory_name . For their meaning refer to the Zsh documentation . Use Of add-zle-hook-widget To Install Zle Hooks # Zle editor is the part of the Zsh that is responsible for receiving the text from the user. It can be said that it\u2019s based on widgets, which are nothing more than Zsh functions that are allowed to be ran in Zle context, i.e. from the Zle editor (plus a few minor differences, like e.g.: the $WIDGET parameter that\u2019s automatically set by the Zle editor). The syntax of the call is: add-zle-hook-widget [ -L | -dD ] [ -Uzk ] hook widgetname The call resembles the syntax of the add-zsh-hook function. The only difference is that it takes a widgetname , not a function name, and that the hook is being one of: isearch-exit , isearch-update , line-pre-redraw , line-init , line-finish , history-line-set , or keymap-select . Their meaning is explained in the Zsh documentation . The use of this function is recommended because it allows to install multiple hooks per each hook entry. Before introducing the add-zle-hook-widget function the \"normal\" way to install a hook was to define widget with the name of one of the special widgets. Now, after the function has been introduced in Zsh 5.3 it should be used instead. Appendix A: Revision History (History Of Updates To The Document) # v0.95, 07/31/2019: Plugin unload function *_unload_plugin \u2192 *_plugin_unload v0.94, 07/20/2019: Add initial version of the best practices section v0.93, 07/20/2019: 1/ Add the second line to the $0 handling. v0.93, 07/20/2019: 2/ Reformat to 80 columns v0.92, 07/14/2019: 1/ Rename LOADED_PLUGINS to zsh_loaded_plugins. v0.92, 07/14/2019: 2/ Suggest that $ZPFX is optional. v0.91, 06/02/2018: Fix the link to the PDF for Github. v0.9, 12/12/2017: Remove ZERO references (wrong design), add TOC. Reminder: The date format that uses slashes is MM/DD/YYYY .","title":"Zsh Plugin Standard"},{"location":"zsh-plugin-standard/#zsh_plugin_standard","text":"This document defines the Zsh Plugin Standard. Zplugin fully supports this standard. This document is also available as a PDF .","title":"Zsh Plugin Standard"},{"location":"zsh-plugin-standard/#what_is_a_zsh_plugin","text":"Historically, Zsh plugins were first defined by Oh My Zsh. They provide for a way to package together files that extend or configure the shell\u2019s functionality in a particular way. At a simple level, a plugin: Has its directory added to $fpath ( Zsh documentation ). Has its first *.plugin.zsh file sourced (or *.zsh , init.zsh , *.sh , these are non-standard). The first point allows plugins to provide completions and functions that are loaded via Zsh\u2019s autoload mechanism (a single function per-file). From a more broad perspective, a plugin consists of: A directory containing various files (main script, autoload functions, completions, Makefiles, backend programs, documentation). A sourcable script that obtains the path to its directory via $0 (see the next section for a related enhancement proposal). A Github (or other site) repository identified by two components username / pluginname . A software package containing any type of command line artifacts \u2013 when used with advanced plugin managers that have hooks, can run Makefiles, add directories to $PATH . Below follow proposed enhancements and codifications of the definition of a \"Zsh plugin\" and the actions of plugin managers \u2013 the proposed standardization.","title":"What is a Zsh plugin?"},{"location":"zsh-plugin-standard/#146_standardized_0_handling","text":"To get the plugin\u2019s location, plugins should do: 0=\"${${ZERO:-${0:#$ZSH_ARGZERO}}:-${(%):-%N}}\" 0=\"${${(M)0:#/*}:-$PWD/$0}\" # Then ${0:h} to get plugin\u2019s directory The one-line code above will: Be backwards-compatible with normal $0 setting and usage. Use ZERO if it\u2019s not empty, the plugin manager will be easily able to alter effective $0 before loading a plugin, this allows for e.g. eval \"$(<plugin)\" , which can be faster than source ( comparison , note that it\u2019s not for a compiled script). Use $0 if it doesn\u2019t contain the path to the Zsh binary, plugin manager will still be able to set $0 , although more difficultly (requires unsetopt function_argzero before sourcing plugin script, and 0=\u2026\u200b assignment), unsetopt function_argzero will be detected (it causes $0 not to contain plugin-script path, but path to Zsh binary, if not overwritten by a 0=\u2026\u200b assignment), setopt posix_argzero will be detected (as above). Use %N prompt expansion flag, which always gives absolute path to script, plugin manager cannot alter this (no advanced loading of plugin is possible), but simple plugin-file sourcing (without a plugin manager) will be saved from breaking caused by the mentioned *_argzero options, so this is a very good last-resort fallback. Finally, in the second line, it will ensure that $0 contains an absolute path by prepending it with $PWD if necessary. The goal is flexibility, with essential motivation to support eval \"$(<plugin)\" and definitely solve setopt no_function_argzero and setopt posix_argzero cases. A plugin manager will be even able to convert a plugin to a function (author implemented such proof of concept functionality, it\u2019s fully possible \u2013 also in an automatic fashion), but performance differences of this are yet unclear. It might however provide a use case. The last, 5 th point also allows to use the $0 handling in scripts (i.e. runnables with the hashbang #!\u2026 ) to get the directory in which the script file resides.","title":"1. Standardized $0 Handling"},{"location":"zsh-plugin-standard/#246_unload_function","text":"If a plugin is named e.g. kalc (and is available via an-user/kalc plugin-ID), then it can provide a function, kalc_plugin_unload , that can be called by a plugin manager to undo the effects of loading that plugin. A plugin manager can implement its own tracking of changes made by a plugin so this is in general optional. However, to properly unload e.g. a prompt, dedicated tracking (easy to do for the plugin creator) can provide better, predictable results. Any special, uncommon effects of loading a plugin are possible to undo only by a dedicated function. However, an interesting compromise approach is available \u2013 to withdraw only the special effects of loading a plugin via the dedicated, plugin-provided function and leave the rest to the plugin manager. The value of such approach is that maintaining of such function (if it is to withdraw all plugin side-effects) can be a daunting task requiring constant monitoring of it during the plugin develoment process.","title":"2. Unload Function"},{"location":"zsh-plugin-standard/#346_plugin_manager_activity_indicator","text":"Plugin managers should set the $zsh_loaded_plugins array to contain all previously loaded plugins and the plugin currently being loaded (as the last element). This will allow any plugin to: Check which plugins are already loaded. Check if it is being loaded by a plugin manager (i.e. not just sourced). The first item allows a plugin to e.g. issue a notice about missing dependencies. Instead of issuing a notice, it may be able to satisfy the dependencies from resources it provides. For example, pure prompt provides zsh-async dependency library within its source tree, which is normally a separate project. Consequently, the prompt can decide to source its private copy of zsh-async , having also reliable $0 defined by previous section (note: pure doesn\u2019t normally do this). The second item allows a plugin to e.g. set up $fpath , knowing that plugin manager will not handle this: if [[ (${+zsh_loaded_plugins} = 0 || ${zsh_loaded_plugins[-1]} != */kalc) \\ && -z ${fpath[(r)${0:h}]} ]] then fpath+=( \"${0:h}\" ) fi This will allow user to reliably source the plugin without using a plugin manager.","title":"3. Plugin Manager Activity Indicator"},{"location":"zsh-plugin-standard/#446_global_parameter_with_prefix_for_make_configure_etc","text":"Plugin managers may export the parameter $ZPFX which should contain a path to a directory dedicated for user-land software, i.e. for directories $ZPFX/bin , $ZPFX/lib , $ZPFX/share , etc. Suggested name of the directory is polaris , Zplugin uses this name and places this directory at ~/.zplugin/polaris by default. User can then configure hooks (feature of e.g. zplug and Zplugin) to invoke e.g. make PREFIX=$ZPFX install at clone & update of the plugin to install software like e.g. tj/git-extras . This is a developing role of Zsh plugin managers as package managers, where .zshrc has a similar role to Chef or Puppet configuration and allows to declare system state, and have the same state on different accounts / machines. No-narration facts-list related to $ZPFX : export ZPFX=\"$HOME/polaris\" (or e.g. $HOME/.zplugin/polaris ) make PREFIX=$ZPFX install ./configure --prefix=$ZPFX cmake -DCMAKE_INSTALL_PREFIX=$ZPFX . zplugin ice make\"PREFIX=$ZPFX install\" zplug \u2026 hook-build:\"make PREFIX=$PFX install\"","title":"4. Global Parameter With PREFIX For Make, Configure, Etc."},{"location":"zsh-plugin-standard/#zsh_plugin-programming_best_practices","text":"The document is to define a Zsh-plugin but also to serve as an information source for plugin creators. Therefore, it covers also a best practices information in this section.","title":"Zsh Plugin-Programming Best Practices"},{"location":"zsh-plugin-standard/#use_of_add-zsh-hook_to_install_hooks","text":"Zsh ships with a function add-zsh-hook . It has the following invocation syntax: add-zsh-hook [ -L | -dD ] [ -Uzk ] hook function The command installs a function as one of the supported zsh hook entries. which are one of: chpwd , periodic , precmd , preexec , zshaddhistory , zshexit , zsh_directory_name . For their meaning refer to the Zsh documentation .","title":"Use Of add-zsh-hook To Install Hooks"},{"location":"zsh-plugin-standard/#use_of_add-zle-hook-widget_to_install_zle_hooks","text":"Zle editor is the part of the Zsh that is responsible for receiving the text from the user. It can be said that it\u2019s based on widgets, which are nothing more than Zsh functions that are allowed to be ran in Zle context, i.e. from the Zle editor (plus a few minor differences, like e.g.: the $WIDGET parameter that\u2019s automatically set by the Zle editor). The syntax of the call is: add-zle-hook-widget [ -L | -dD ] [ -Uzk ] hook widgetname The call resembles the syntax of the add-zsh-hook function. The only difference is that it takes a widgetname , not a function name, and that the hook is being one of: isearch-exit , isearch-update , line-pre-redraw , line-init , line-finish , history-line-set , or keymap-select . Their meaning is explained in the Zsh documentation . The use of this function is recommended because it allows to install multiple hooks per each hook entry. Before introducing the add-zle-hook-widget function the \"normal\" way to install a hook was to define widget with the name of one of the special widgets. Now, after the function has been introduced in Zsh 5.3 it should be used instead.","title":"Use Of add-zle-hook-widget To Install Zle Hooks"},{"location":"zsh-plugin-standard/#appendix_a_revision_history_history_of_updates_to_the_document","text":"v0.95, 07/31/2019: Plugin unload function *_unload_plugin \u2192 *_plugin_unload v0.94, 07/20/2019: Add initial version of the best practices section v0.93, 07/20/2019: 1/ Add the second line to the $0 handling. v0.93, 07/20/2019: 2/ Reformat to 80 columns v0.92, 07/14/2019: 1/ Rename LOADED_PLUGINS to zsh_loaded_plugins. v0.92, 07/14/2019: 2/ Suggest that $ZPFX is optional. v0.91, 06/02/2018: Fix the link to the PDF for Github. v0.9, 12/12/2017: Remove ZERO references (wrong design), add TOC. Reminder: The date format that uses slashes is MM/DD/YYYY .","title":"Appendix A: Revision History (History Of Updates To The Document)"}]}